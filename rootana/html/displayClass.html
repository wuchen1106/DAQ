<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ROOT Analyzer: Display Classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="displayClass">Display Classes </a></h1><h2><a class="anchor" id="displayIntro">
Introduction</a></h2>
<p><a class="el" href="a00037.html">TRootanaDisplay</a> is an attempt to provide a simple way of making ROOT event displays that can quickly be used to show ADC/TDC spectrum or whatever else you'd like to plot.</p>
<h2><a class="anchor" id="displayUsage">
Using TRootanaDisplay</a></h2>
<p><a class="el" href="a00037.html">TRootanaDisplay</a> is an abstract base class for event displays. Users need to define a class that derives from this class in order to make an event display. The only method that users must implement is the method AddAllCanvas(), where the user defines which tabs to use.</p>
<p>The user then needs to define how they what to update and plot histograms. The updating of histograms happens for each event. In online mode, the plotting of histograms only happens for each NN events, where NN is controlled by the user. For offline mode the plotting happens for each event.</p>
<p>There are three ways that users can decide to update and plot histograms: 1) They can create histograms in their event display class and then fill the methods UpdateHistograms(TDataContainer) and PlotCanvas(TDataContainer). This histograms can then fill in the canvases that are added using AddSingleCanvas(std::string name). 2) They can create classes that are derived from <a class="el" href="a00012.html">TCanvasHandleBase</a>. The derived classes are then added using the method AddSingleCanvas(TCanvasHandleBase* handleClass). 3) They can create a histogram-set class (derived from <a class="el" href="a00023.html">THistogramArrayBase</a>) and pass it to <a class="el" href="a00020.html">TFancyHistogramCanvas</a>. This provides a richer set of button control of the histogram display.</p>
<p>There is no substantial difference between the first two methods. The second method is mainly meant to allow the user to separate the methods into separate files for code cleaniness.</p>
<p>The actual ROOT GUI is encapsulated in a separate class <a class="el" href="a00024.html">TMainDisplayWindow</a>. The <a class="el" href="a00037.html">TRootanaDisplay</a> has an instance of this <a class="el" href="a00024.html">TMainDisplayWindow</a> class. Users will be need to access the <a class="el" href="a00024.html">TMainDisplayWindow</a> by calling</p>
<p><a class="el" href="a00037.html#aa6680d736ac16cd6f55e050d02dcfb5f">TRootanaDisplay::GetDisplayWindow()</a></p>
<p>in order to grab the particular canvas that we want plot on.</p>
<p>The program <a class="el" href="a00124.html">display_example.cxx</a> shows an nice example plot using all three methods for histogram filling.</p>
<h2><a class="anchor" id="roodyComp">
Comparison of RootanaDisplay and Roody</a></h2>
<p>rootana also provides a different way of visualizing histograms through roody and the TNetDirectoryServer. Should the user use <a class="el" href="a00037.html">TRootanaDisplay</a> or roody? The following are some of the differences between the two tools:</p>
<ul>
<li>roody requires two programs to be running: an analyzer that produces the histogram and the roody program for displaying them. This has some advantages in that you can independently restart the roody part; also you can run the analyzer on the midas server machine, but run roody on your desktop. But it also some disadvantages in complexity, since you need to keep track of both programs.</li>
<li>Using roody is simpler from a coding point of view, since all the visualization is handled for you. The <a class="el" href="a00037.html">TRootanaDisplay</a> option requires some understanding of ROOT canvases and GUIs.</li>
<li>roody can only handle a limited set of ROOT classes, like TH1 histograms. If you want to be able to plot more complicated ROOT options or plot them in a more complicated way (overlaying histograms, fits and labels) then <a class="el" href="a00037.html">TRootanaDisplay</a> is a better option.</li>
</ul>
<p>So, in summary: if you are only producing a simple set of ROOT histograms and/or you don't want to do much programming then roody might be the right solution; if you want complicated plots and don't mind using ROOT display classes, then <a class="el" href="a00037.html">TRootanaDisplay</a> is the way to go.</p>
<p>Of course, the user can easily have a program that implements both solutions and get the best of both worlds.</p>
<p>T. Lindner </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 15 May 2013 for ROOT Analyzer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
