<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Midas: Frontend Routines associated with Equipments</title>
<link href="midox.css" rel="stylesheet" type="text/css">
<!--
<link href="doxygen.css" rel="stylesheet" type="text/css">
-->
<link href="tabs.css" rel="stylesheet" type="text/css">

<script type="text/javascript"  src="navigation.js">
</script>

</head>

<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">Midas Documentation</a>&nbsp;&raquo&nbsp;<a class="el" href="FrontendOperation.html">SECTION 6: Frontend Operation</a>&nbsp;&raquo&nbsp;<a class="el" href="Frontend_code.html">Frontend code</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="FE_eq_event_routines">Frontend Routines associated with Equipments </a></h1><p><a class="anchor" id="idx_event_readout_routines"></a> <br/>
  
 
<script type="text/javascript">
pages( "FE_sequence", "FrontendOperation",  "FE_event_notification","FE_eq_event_routines","end" ); // back index next {top bottom}
// section parameters: last section; top of this section; next section
sections("RunControl","FrontendOperation","DataAnalysis");
</script>
 <br/>
 <br/>
 <a class="anchor" id="idx_event_polled"></a> </p>
<h2><a class="anchor" id="FE_poll_event">
Polled event</a></h2>
<p>If the <a class="el" href="FE_table.html#FE_tbl_EqType">Equipment Type</a> is <a class="el" href="FE_table.html#FE_tbl_EqPolled">EQ_POLLED</a>, the <b><a class="el" href="mfe_8c.html#a98cc3257284af91fa0e8da10ddf227c8">poll_event()</a></b> routine will be called as often as possible over the corresponding <a class="el" href="FE_table.html#FE_tbl_EqPolled">poll time</a> (e.g. 500ms) given by each polling equipment.</p>
<p>In this case, the <a class="el" href="FE_eqdec.html#FE_Example_equipment_structure">Equipment declaration</a> would have this form:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="structeqpmnt.html">EQUIPMENT</a> equipment[] = {

      { <span class="stringliteral">&quot;Trigger&quot;</span>,            <span class="comment">// equipment name</span>
        {
          ...
          EQ_POLLED,          <span class="comment">// equipment type</span>
          ...
          500,                <span class="comment">// poll for 500ms </span>
          ...
          <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,},
       <a class="code" href="fevmemodules_8c.html#a9c54bafa1af403e5e4737f9d8d5aba07">read_trigger_event</a>,    <span class="comment">// readout routine </span>
       ...
</pre></div><p>The user must provide suitable code in the routine <b><a class="el" href="mfe_8c.html#a98cc3257284af91fa0e8da10ddf227c8">poll_event()</a></b>.</p>
<p>The code below shows a typical LAM polling loop.<br/>
 In the case of CAMAC, the <b>source</b> corresponds to a bitwise LAM station able to generate LAM for that particular equipment. If the LAM is ORed for several stations and is independent of the equipment, the LAM test can be simplified (see example below) </p>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
<caption align="bottom">Examples of poll_event routines </caption>
<tr>
<td style="vertical-align: top; text-align: center; background-color: rgb(255, 255, 153);"><p><span style="font-weight: bold;">VME :</span>  </p>
</td><td style="vertical-align: top; text-align: center; background-color: rgb(255, 255, 204);"><p><span style="font-weight: bold;">CAMAC :</span>  </p>
</td></tr>
<tr>
<td><div class="fragment"><pre class="fragment"><a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> <a class="code" href="mfe_8c.html#a98cc3257284af91fa0e8da10ddf227c8">poll_event</a>(<a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> source, <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> count, <a class="code" href="vt2_8h.html#a239c7f0d40651c3e419c5b9651507d14">BOOL</a> test)
{
<span class="comment">/* Polling routine for events. </span>
<span class="comment">   Returns TRUE if event is available. </span>
<span class="comment">   If test equals TRUE, don&apos;t return. </span>
<span class="comment">   The test flag is used to time the polling.</span>
<span class="comment">*/</span>

  <span class="keywordtype">int</span> i;
  <span class="keywordtype">int</span> lam = 0;

  <span class="keywordflow">for</span> (i = 0; i &lt; count; i++, lam++) {
    lam = <a class="code" href="vmeio_8c.html#af6e6d51d02e674a8a2f313c12bf98a1b">vmeio_CsrRead</a>(myvme, <a class="code" href="fevmemodules_8c.html#aa914897ada170e3d2b39940ef62467cf">VMEIO_BASE</a>);
    <span class="keywordflow">if</span> (lam)
      <span class="keywordflow">if</span> (!test)
        <span class="keywordflow">return</span> lam;
  }

  <span class="keywordflow">return</span> 0;
}
</pre></div> </td><td><p></p>
<div class="fragment"><pre class="fragment"><a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> <a class="code" href="mfe_8c.html#a98cc3257284af91fa0e8da10ddf227c8">poll_event</a>(<a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> source, <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> count, <a class="code" href="vt2_8h.html#a239c7f0d40651c3e419c5b9651507d14">BOOL</a> test)
{
<span class="comment">/* Polling routine for events. </span>
<span class="comment">   Returns TRUE if event is available. </span>
<span class="comment">   If test equals TRUE, don&apos;t return. </span>
<span class="comment">   The test flag is used to time the polling.</span>
<span class="comment"> */</span>
   <span class="keywordtype">int</span>   i;
   <a class="code" href="sis3801_8h.html#a408a2366473807fbe658ba18e75dea66">DWORD</a> lam;
 
   <span class="keywordflow">for</span> (i=0 ; i&lt;count ; i++)
   {
     <a class="code" href="group__mcstdfunctionh.html#ga4b6c60f375489ea1dacc20ba3f2a4bd8">cam_lam_read</a>(<a class="code" href="group__midasincludecode.html#gafac465450c8035c37ba5482970e026eb">LAM_SOURCE_CRATE</a>(source), &amp;lam);
     <span class="comment">// Either ... any of the equipment LAM</span>
     <span class="keywordflow">if</span> (lam &amp; <a class="code" href="group__midasincludecode.html#gae70f372186346224788f2980de071736">LAM_SOURCE_STATION</a>(source))
     <span class="comment">//  </span>
     <span class="comment">// Or ... any LAM (independent of the equipment)</span>
     <span class="keywordflow">if</span> (lam)                             

       <span class="keywordflow">if</span> (!test)
         <span class="keywordflow">return</span> lam;
   }
   <span class="keywordflow">return</span> 0;
} 
</pre></div> </td></tr>
</table>
<p>An <a class="el" href="FE_eq_event_routines.html#FE_poll_or_interrupt_readout_routine">event readout routine</a> must also be provided by the user (see below).</p>
<p><br/>
</p>
<p><br/>
 <a class="anchor" id="idx_event_interrupt"></a> </p>
<h2><a class="anchor" id="FE_interrupt_event">
Interrupt event</a></h2>
<p>If the Equipment type is <a class="el" href="FE_table.html#FE_tbl_EqType">EQ_INTERRUPT</a>, an interrupt configuration routine called <a class="el" href="mfe_8c.html#a681a5d1fe2e8a4735bcf03824ffb3e81">interrupt_configure()</a> must be provided in the <a class="el" href="frontend_8c.html">frontend.c</a> by the user.</p>
<p>The interrupt configuration routine has the following declaration: </p>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
<caption align="bottom">Examples of interrupt_configure routines </caption>
<tr>
<td style="vertical-align: top; text-align: center; background-color: rgb(255, 255, 153);"><p><span style="font-weight: bold;">VME :</span>  </p>
</td><td style="vertical-align: top; text-align: center; background-color: rgb(255, 255, 204);"><p><span style="font-weight: bold;">CAMAC :</span>  </p>
</td></tr>
<tr>
<td><div class="fragment"><pre class="fragment"><span class="comment">/*-- Interrupt configuration --------------------------*/</span>
<a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> <a class="code" href="mfe_8c.html#a681a5d1fe2e8a4735bcf03824ffb3e81">interrupt_configure</a>(<a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> cmd, <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> source, PTYPE adr)
{
  <span class="keywordtype">int</span> vec = 0;
  <span class="keywordflow">switch</span> (cmd) 
  {
    <span class="keywordflow">case</span> <a class="code" href="group__err26.html#gaab5043b2fd69a86d3bcecfb3fd8f7af3">CMD_INTERRUPT_ENABLE</a>:
      <span class="keywordflow">if</span> (inRun) <a class="code" href="group__mvmestdfunctionh.html#ga901e510ac4c207e424e944ee92c5ea65">mvme_write_value</a>(myvme, VLAM_BASE+4, 0x1);
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <a class="code" href="group__err26.html#gaa12884ae2e3cbffa489d7c5074a029f7">CMD_INTERRUPT_DISABLE</a>:
      <span class="keywordflow">if</span> (inRun) <a class="code" href="group__mvmestdfunctionh.html#ga901e510ac4c207e424e944ee92c5ea65">mvme_write_value</a>(myvme, VLAM_BASE+4, 0x0);
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <a class="code" href="group__err26.html#ga8a891110d186a3a4b02f6dfde253efb2">CMD_INTERRUPT_ATTACH</a>:
      <a class="code" href="group__mvmestdfunctionh.html#gaaed1e33d2affe73c5afea1ce30b6c25b">mvme_set_dmode</a>(myvme, <a class="code" href="group__mvmestdinclude.html#ga1106eeff8cdbd2cfb5516f7feea8c1ff">MVME_DMODE_D32</a>);
      <a class="code" href="group__mvmestdfunctionh.html#gae1e6cd30960647ba33cb1fc2e8d8cba8">mvme_interrupt_attach</a>(myvme, <a class="code" href="fevmemodules_8c.html#aed01298d37e73ed9737c8a6b70e67caa">INT_LEVEL</a>, <a class="code" href="fevmemodules_8c.html#aa992c6e0d30eebad60b642ec25681bcb">INT_VECTOR</a>, 
                (<span class="keywordtype">void</span> *)adr, &amp;myinfo);
      <a class="code" href="group__mvmestdfunctionh.html#ga901e510ac4c207e424e944ee92c5ea65">mvme_write_value</a>(myvme, VLAM_BASE+0x10, <a class="code" href="fevmemodules_8c.html#aa992c6e0d30eebad60b642ec25681bcb">INT_VECTOR</a>);
      vec = <a class="code" href="group__mvmestdfunctionh.html#ga5cab05257f96039738eec34ec330e0d8">mvme_read_value</a>(myvme, VLAM_BASE+0x10);
      printf(<span class="stringliteral">&quot;Interrupt Attached to 0x%x for vector:0x%x\n&quot;</span>,
                     adr, vec&amp;0xFF);
      <span class="keywordflow">break</span>;

    <span class="keywordflow">case</span> <a class="code" href="group__err26.html#gae055008eb0238aaf491eda741abcd26d">CMD_INTERRUPT_DETACH</a>:
      printf(<span class="stringliteral">&quot;Interrupt Detach\n&quot;</span>);
      <span class="keywordflow">break</span>;
   }
   <span class="keywordflow">return</span> SUCCESS;
}
</pre></div> </td><td><div class="fragment"><pre class="fragment"><a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> <a class="code" href="mfe_8c.html#a681a5d1fe2e8a4735bcf03824ffb3e81">interrupt_configure</a>(<a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> cmd, <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> source [], PTYPE adr)
{
   <span class="keywordflow">switch</span>(cmd)
     {
      <span class="keywordflow">case</span> <a class="code" href="group__err26.html#gaab5043b2fd69a86d3bcecfb3fd8f7af3">CMD_INTERRUPT_ENABLE</a>:
        <a class="code" href="group__mcstdfunctionh.html#ga5d95207e772c732839b0010706c1ecc9">cam_interrupt_enable</a>();
        <span class="keywordflow">break</span>;

      <span class="keywordflow">case</span> <a class="code" href="group__err26.html#gaa12884ae2e3cbffa489d7c5074a029f7">CMD_INTERRUPT_DISABLE</a>:
        <a class="code" href="group__mcstdfunctionh.html#ga21c6d5bd474679bf5a810560564c7677">cam_interrupt_disable</a>();
        <span class="keywordflow">break</span>;

      <span class="keywordflow">case</span> <a class="code" href="group__err26.html#ga8a891110d186a3a4b02f6dfde253efb2">CMD_INTERRUPT_ATTACH</a>:
        <a class="code" href="group__mcstdfunctionh.html#gaf23c4ba5de04fcabcc9ce5bb7441330b">cam_interrupt_attach</a>((<span class="keywordtype">void</span> (*)())adr);
        <span class="keywordflow">break</span>;

      <span class="keywordflow">case</span> <a class="code" href="group__err26.html#gae055008eb0238aaf491eda741abcd26d">CMD_INTERRUPT_DETACH</a>:
        <a class="code" href="group__mcstdfunctionh.html#ga0abf493fdf6fac4a8dd284d5998e6b30">cam_interrupt_detach</a>();
        <span class="keywordflow">break</span>;

      }
  <span class="keywordflow">return</span> <a class="code" href="group__err21.html#ga0180947941230d805f5dbb6f1801c17c">CM_SUCCESS</a>; 
}
</pre></div> </td></tr>
</table>
<p>Under the four commands listed above, the user must implement the hardware operation needed to perform the requested action. In the Midas <b> drivers </b> directory examples can be found of such an interrupt code for CAMAC. See source code such as hyt1331.c,ces8210.c .</p>
<p>An event readout routine must also be provided by the user in <a class="el" href="frontend_8c.html">frontend.c</a> . In the case of POLLED or INTERRUPT events, the event readout routine is called an <a class="el" href="FE_eq_event_routines.html#FE_poll_or_interrupt_readout_routine">interrupt readout routine</a>. An example is shown below.</p>
<p><br/>
</p>
<p><br/>
</p>
<h2><a class="anchor" id="FE_readout_routine">
Event Readout routines</a></h2>
<p>An event readout routine (called when an event occurs) is usually of the form </p>
<div class="fragment"><pre class="fragment"><a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> function_name ( <span class="keywordtype">char</span> *pevent ... )
{
   <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> event_size;

   ........  <span class="comment">// read data from hardware</span>
   ........  <span class="comment">// pack into banks depending on format</span>
   ........
   <span class="keywordflow">return</span> (event_size);
}
</pre></div><p> where the first argument of the readout function (<span style="font-weight: bold;">pevent</span>)&nbsp; provides the pointer to the newly constructed event, and points to the first valid location for storing the data. <br/>
 <b>NOTE:</b> </p>
<ul>
<li>
The <span style="font-weight: bold;">return value is the event size, and must be the number of bytes collected in this function</span>.  </li>
<li>
The <b>event serial number</b> will be incremented by one for every call to the readout routine, <span style="font-weight: bold;">as long as the returned size is non-zero</span>.  </li>
<li>
If the <b>returned value is set to zero</b>, the event will be dismissed and the serial number to that event will be decremented by one.  </li>
</ul>
<p><br/>
</p>
<p><br/>
 </p>
<h3><a class="anchor" id="FE_poll_or_interrupt_readout_routine">
Polled or Interrupt readout routine</a></h3>
<p>In the case of an Interrupt or Polled event, the content of the memory location pointed to by <b>pevent</b> prior to its use in the readout function, contains the interrupt source bitwise register. This feature can be exploited in order to identify which hardware module has triggered the readout when multiple interrupts have been assigned to the same readout function.</p>
<p>The examples below show a VME interrupt source and a CAMAC multiple LAM interrupt source for a given equipment. Depending whether USE_INT is defined, the Equipment will either use a <a class="el" href="FE_eq_event_routines.html#FE_poll_event">Polled</a> or an <a class="el" href="FE_eq_event_routines.html#FE_interrupt_event">Interrupt</a> mechanism. <br/>
 The Equipment declaration is of the form: </p>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
<caption align="bottom">Examples of POLLED or INTERRUPT Equipment list </caption>
<tr>
<td style="vertical-align: top; text-align: center; background-color: rgb(255, 255, 153);"><p><span style="font-weight: bold;">VME :</span>  </p>
</td><td style="vertical-align: top; text-align: center; background-color: rgb(255, 255, 204);"><p><span style="font-weight: bold;">CAMAC :</span>  </p>
</td></tr>
<tr>
<td><div class="fragment"><pre class="fragment"><a class="code" href="structeqpmnt.html">EQUIPMENT</a> equipment[] = {

   {<span class="stringliteral">&quot;Trigger&quot;</span>,  <span class="comment">/* equipment name */</span>
     ...
#ifdef USE_INT
     EQ_INTERRUPT, <span class="comment">/* equipment type */</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>     EQ_POLLED,    <span class="comment">/* equipment type */</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span> <span class="comment">/* interrupt source: crate 0, all stations */</span>
     <a class="code" href="group__midasincludecode.html#ga93fde3913a488880c4f96267e24579ee">LAM_SOURCE</a>(0, 0x0),
     ....
     <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,},
    <a class="code" href="fevmemodules_8c.html#a9c54bafa1af403e5e4737f9d8d5aba07">read_trigger_event</a>, <span class="comment">/* readout routine */</span>
    NULL, NULL,
    trigger_bank_list,
    }
</pre></div> </td><td><div class="fragment"><pre class="fragment">    <a class="code" href="structeqpmnt.html">EQUIPMENT</a> equipment[] = {
      { <span class="stringliteral">&quot;Trigger&quot;</span>,  <span class="comment">// equipment name</span>
         {    
            ...
<span class="comment">// the same readout code will be used for</span>
<span class="comment">// either Interrupt or Polled equipment</span>
#ifdef USE_INT
            EQ_INTERRUPT,
<span class="preprocessor">#else                     </span>
<span class="preprocessor"></span>            EQ_POLLED,
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>            <a class="code" href="group__midasincludecode.html#ga93fde3913a488880c4f96267e24579ee">LAM_SOURCE</a>(JW_C,  <a class="code" href="group__midasincludecode.html#ga479219e07f43223f74ff8638705a804e">LAM_STATION</a>(GE_N)
                   | <a class="code" href="group__midasincludecode.html#ga479219e07f43223f74ff8638705a804e">LAM_STATION</a>(JW_N)), <span class="comment">// interrupt source </span>
            ...
            <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,},
       <a class="code" href="fevmemodules_8c.html#a9c54bafa1af403e5e4737f9d8d5aba07">read_trigger_event</a>,   <span class="comment">// event readout routine </span>
       ...
</pre></div> </td></tr>
</table>
<p>Note that the LAM_SOURCE macro is used in both cases. It simply codes the <a class="el" href="structparameters.html">parameters</a> into a bitwise register.</p>
<p>The readout routine would contains code such as </p>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">
<caption align="bottom">Examples of readout routines </caption>
<tr>
<td style="vertical-align: top; text-align: center; background-color: rgb(255, 255, 153);"><p><span style="font-weight: bold;">VME :</span>  </p>
</td><td style="vertical-align: top; text-align: center; background-color: rgb(255, 255, 204);"><p><span style="font-weight: bold;">CAMAC :</span>  </p>
</td></tr>
<tr>
<td><div class="fragment"><pre class="fragment"><a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> <a class="code" href="fevmemodules_8c.html#a9c54bafa1af403e5e4737f9d8d5aba07">read_trigger_event</a>(<span class="keywordtype">char</span> *pevent, <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> off)
{
<span class="preprocessor">#if defined VADC0_CODE</span>
<span class="preprocessor"></span>  <a class="code" href="sis3801_8h.html#a408a2366473807fbe658ba18e75dea66">DWORD</a>  *pdata;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#if defined VADC0_CODE</span>
<span class="preprocessor"></span>  <span class="comment">/* read ADC0 data */</span>
  <a class="code" href="v792_8c.html#a93c9ec6788ab26b8dc1ca782761f91ac">v792_EvtCntRead</a>(myvme, VADC0_BASE, &amp;evtcnt);
  ........
  <span class="comment">/* Read Event */</span>
  <a class="code" href="v792_8c.html#a723985757a28f135d0b1224a85accb62">v792_EventRead</a>(myvme, VADC0_BASE, pdata, &amp;nentry);
  ........
  <a class="code" href="v792_8c.html#a526dbfe955e68a6e982bb5a3345b74e3">v792_DataClear</a>(myvme, VADC0_BASE);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  ........
  <span class="keywordflow">return</span> (size);
}
</pre></div>  </td><td><div class="fragment"><pre class="fragment">  <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> <a class="code" href="fevmemodules_8c.html#a9c54bafa1af403e5e4737f9d8d5aba07">read_trigger_event</a>(<span class="keywordtype">char</span> *pevent, <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> off)
  {
    <a class="code" href="sis3801_8h.html#a408a2366473807fbe658ba18e75dea66">DWORD</a> lam;

    lam = *((<a class="code" href="sis3801_8h.html#a408a2366473807fbe658ba18e75dea66">DWORD</a> *)pevent);

    <span class="comment">// check LAM versus MCS station</span>
    <span class="comment">// The clear is performed at the end of the readout function</span>
    <span class="keywordflow">if</span> (lam &amp; <a class="code" href="group__midasincludecode.html#ga479219e07f43223f74ff8638705a804e">LAM_STATION</a>(JW_N))
    {
       <span class="comment">// read MCS event </span>
       size = read_mcs_event(pevent);
       ...
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lam &amp; <a class="code" href="group__midasincludecode.html#ga479219e07f43223f74ff8638705a804e">LAM_STATION</a>(GE_N))
    {
       ...
       <span class="comment">// read GE event</span>
       size = read_ge_event(pevent);
       ...
     }
     clear_LAM(); <span class="comment">// clear all LAMs</span>
  <span class="keywordflow">return</span> size;
} 
</pre></div>  </td></tr>
</table>
<p><b>NOTE:</b> <br/>
 In the CAMAC example above, the Midas Event Header contains the same Event ID as the Trigger mask for both LAM. The examples <a class="el" href="fevmemodules_8c.html">fevmemodules.c</a> (VME) and <a class="el" href="frontend_8c.html">frontend.c</a> (CAMAC) contain a complete example of <a class="el" href="fevmemodules_8c.html#a9c54bafa1af403e5e4737f9d8d5aba07">read_trigger_event()</a>.</p>
<p><br/>
</p>
<p><br/>
 </p>
<h3><a class="anchor" id="FE_other_event">
General readout function</a></h3>
<p>If the <a class="el" href="FE_table.html#FE_tbl_EqType">Equipment type</a> is <b>not</b> EQ_INTERRUPT or EQ_POLLED, the readout routine is the only event routine that the user needs to provide in <a class="el" href="frontend_8c.html">frontend.c</a> .</p>
<p>In this case (e.g. a <b>periodic</b> event) the <a class="el" href="FE_eqdec.html#FE_Example_equipment_structure">Equipment declaration</a> may have this form: </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="structeqpmnt.html">EQUIPMENT</a> equipment[] = {
      { <span class="stringliteral">&quot;Scaler&quot;</span>,           <span class="comment">// equipment name</span>
         {    
            ...
            <a class="code" href="group__mdefineh.html#ga58e919e4e401b299c1834be965c3e78c">EQ_PERIODIC</a>     <span class="comment">// equipment type</span>
            0,              <span class="comment">// interrupt source (ignored) </span>
            ...
            10000,          <span class="comment">// period (read every 10s)</span>
            ...
            <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,},
       <a class="code" href="fevmemodules_8c.html#af3ad062393c1437922bae26841d8927c">read_scaler_event</a>,   <span class="comment">// readout routine </span>
       ...
</pre></div><p>An example of a scaler readout routine <a class="el" href="fevmemodules_8c.html#af3ad062393c1437922bae26841d8927c">read_scaler_event()</a> where the data is read out into <a class="el" href="FE_bank_construction.html">data banks</a> is shown below. </p>
<div class="fragment"><pre class="fragment"><a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> <a class="code" href="fevmemodules_8c.html#af3ad062393c1437922bae26841d8927c">read_scaler_event</a>(<span class="keywordtype">char</span> *pevent, <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> off)
{
   <a class="code" href="sis3801_8h.html#a408a2366473807fbe658ba18e75dea66">DWORD</a> *pdata, a;

   <span class="comment">/* init bank structure */</span>
   <a class="code" href="group__bkfunctionc.html#gac6fadde40824dbf7bd70abedd29be2bd">bk_init</a>(pevent);

   <span class="comment">/* create SCLR bank */</span>
   <a class="code" href="group__bkfunctionc.html#ga4bb781187e18834136ed8ac368d53413">bk_create</a>(pevent, <span class="stringliteral">&quot;SCLR&quot;</span>, <a class="code" href="group__mdefineh.html#gafed9e8d519719d7347f9fdb3031201d1">TID_DWORD</a>, &amp;pdata);

   <span class="comment">/* read scaler bank (CAMAC) */</span>
   <span class="keywordflow">for</span> (a = 0; a &lt; N_SCLR; a++)
      <a class="code" href="group__mcstdfunctionh.html#ga84d45a99ef748664e1eead0a5da4d862">cam24i</a>(<a class="code" href="frontend_8c.html#ad927298c4aa5421ba6e9c19a15535a16">CRATE</a>, <a class="code" href="frontend_8c.html#a0da17be6dfbb480af4def8b02ca3e44d">SLOT_SCLR</a>, a, 0, pdata++);
    
   <span class="comment">/* close SCLR bank */</span>
   <a class="code" href="group__bkfunctionc.html#ga132dc71c8f74b478cdcc59bc1d9f6a26">bk_close</a>(pevent, pdata);

   <span class="comment">/* return event size in bytes */</span>
   <span class="keywordflow">return</span> <a class="code" href="group__bkfunctionc.html#ga8fc93de36e62c4328cb6581be7f42a0f">bk_size</a>(pevent);
}
</pre></div><p><br/>
 <hr/>
 <br/>
</p>
<p><a class="anchor" id="idx_event_fragmented"></a> </p>
<h3><a class="anchor" id="FE_fragmented_event">
Fragmented Event</a></h3>
<p>A <b>fragmented</b> event enables very large events (e.g. beyond the Midas configuration limit) to be handled by the system. This is not to be confused with the use of the Event Builder, where "event fragments" are combined by an <a class="el" href="FE_Event_Builder.html#FE_mevb_utility">event-builder</a>.</p>
<p>The event is sent out by the frontend in smaller fragments, and reassembled by the Midas system into one event. This option is useful in experiments where the event rate is not an issue, but the size of the data needs to be extremely large. The Equipment flag <a class="el" href="FE_table.html#FE_tbl_EqFragmented">EQ_FRAGMENTED</a> indicates that the event is fragmented. The <b>fragment size</b> is determined by "max_event_size" in the frontend code <a class="el" href="FE_eq_event_routines.html#FE_frag_max_event_size">(see below)</a>.</p>
<p>The example used <a class="el" href="FE_eq_event_routines.html#FE_tdmusr_equipment">below</a> is taken from the TRIUMF TD-MUSR experiment, where a VME PowerPC (PPC) running VxWorks is used as the frontend cpu, and acts as a Histogramming Memory (HM). The backend computer is a Linux PC.</p>
<p>Depending on the time range (i.e. number of bins selected) the histograms may be very large. The memory of the PPC is limited, and most of the free memory is needed for the HM, so the event buffer size is set to be relatively small. Therefore the histograms can only be sent out in fragments.</p>
<p><a class="anchor" id="idx_event_manual-trigger"></a> </p>
<h3><a class="anchor" id="FE_manual_trigger">
Manual Trigger</a></h3>
<p>Another feature illustrated in this example <a class="el" href="FE_eq_event_routines.html#FE_tdmusr_equipment">below</a> is the <b> Manual Trigger</b>, indicated by the Equipment flag <a class="el" href="FE_table.html#FE_tbl_EqManTrig">EQ_MANUAL_TRIG</a>. This flag causes an extra button to be present on the mhttpd web interface to enable the user to trigger the event. The following image is of the main status page of the MUSR experiment, where two manual trigger buttons are shown, labelled</p>
<ul>
<li>"Trigger Histo event" and</li>
<li>"Trigger Camp event".</li>
</ul>
<p>These have been generated for the Histo and Camp Equipments which were both set up with the EQ_MANUAL_TRIG flag. <br/>
 </p>
<center> <span class="image">mhttpd status page showing Manual Trigger Buttons</span> </p>
<div align="center">
<img src="mantrig.png" alt="mantrig.png"/>
</div>
 </center><p> <br/>
</p>
<p>It is also possible for a <a class="el" href="FE_eq_event_routines.html#FE_backend_Manual_Trigger">client to trigger a manual trigger event</a>. The MUSR custom data archiver (a backend Midas client) controls when an event is sent, by means of a <a class="el" href="FE_eq_event_routines.html#FE_backend_Manual_Trigger">routine</a> that requests an event by triggering the event sending mechanism with a RPC call.</p>
<h4><a class="anchor" id="FE_manual_trig_determine">
How to determine if trigger was a manual trigger</a></h4>
<p>In some cases, the same readout code may be used for two types of event: a manual trigger and (say) a poll event. It is possible to determine whether the readout of an event was triggered by a manual trigger or a regular trigger by adding the following call to the readout routine: </p>
<div class="fragment"><pre class="fragment">  flag = <a class="code" href="group__mbufferh.html#ga5327bc310729f5ec36b917ed13e6ff66">DATA_SIZE</a>(pevent);
</pre></div><p><br/>
 If the result is</p>
<ul>
<li>flag = 0 normal call</li>
<li>flag = 1 manual trigger</li>
</ul>
<h3><a class="anchor" id="FE_tdmusr_equipment">
Equipment declaration for manually-triggered and fragmented event</a></h3>
<p>The Equipment declaration for the manually triggered fragmented histogram event (named Histo) is as follows:</p>
<div class="fragment"><pre class="fragment"> { <span class="stringliteral">&quot;Histo&quot;</span>,             <span class="comment">/* equipment name */</span>
    2, 0,                 <span class="comment">/* event ID, trigger mask */</span>
    <span class="stringliteral">&quot;SYSTEM&quot;</span>,             <span class="comment">/* event buffer */</span>
    <a class="code" href="group__mdefineh.html#gac73e1045dff2b724325100af2e946717">EQ_MANUAL_TRIG</a> |     <span class="comment">/* equipment type */</span>
    <a class="code" href="group__mdefineh.html#ga702ba5dcc4b9f1ccf9a1a37bad62266e">EQ_FRAGMENTED</a>,        <span class="comment">/*    manual trigger, fragmented (no longer periodic)</span>
<span class="comment"> */</span>
    0,                    <span class="comment">/* interrupt source */</span>
    <span class="stringliteral">&quot;MIDAS&quot;</span>,               <span class="comment">/* format */</span>
    TRUE,                 <span class="comment">/* enabled */</span>
    RO_RUNNING | <a class="code" href="group__mdefineh.html#ga5b505930aa1fc780118b4fc75f771464">RO_EOR</a> |
    <a class="code" href="group__mdefineh.html#ga55beb931c834300fea83d24014f235d8">RO_PAUSE</a> | <a class="code" href="group__mdefineh.html#ga549159f6ef3ef7c17261bcccecbe57ec">RO_RESUME</a>, <span class="comment">/* read when running and on end run,pause,resume tran</span>
<span class="comment">sition */</span>
    0,                    <span class="comment">/* not polled */</span>
    0,                    <span class="comment">/* stop run after this event limit */</span>
    0,                    <span class="comment">/* number of sub event */</span>
    0,                    <span class="comment">/* log history */</span>
   <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,
    histo_read,     <span class="comment">/* readout routine */</span>
    NULL,NULL,NULL       <span class="comment">/* keep null */</span>
  },
</pre></div><p>The Histo event can be manually triggered only <b>when running</b>, and is also triggered by the transitions <b>STOP, PAUSE</b> and <b>RESUME</b>, <br/>
indicated by the <a class="el" href="FE_table.html#FE_tbl_ReadOn">Read-On Event flags</a> : <br/>
 <b>RO_RUNNING | RO_EOR | RO_PAUSE | RO_RESUME</b>.</p>
<p><a class="anchor" id="idx_event_fragmented_size"></a> </p>
<h3><a class="anchor" id="FE_frag_max_event_size">
Event size adjustments for fragmented event</a></h3>
<p>The buffer sizes in the frontend must be adjusted to suit the available memory for the event buffer (used for sending out the event fragments) and to determine the maximum fragment size.</p>
<p>The standard sizes in <a class="el" href="frontend_8c.html">frontend.c</a> are </p>
<div class="fragment"><pre class="fragment">    <span class="comment">//maximum event size produced by this frontend</span>
    <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> max_event_size = 200000; <span class="comment">/* must be less than MAX_EVENT_SIZE in midas.h */</span> 

    <span class="comment">// maximum event size for fragmented events (ignored unless flag EQ_FRAGMENTED is true) </span>
    <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> max_event_size_frag = 5 * 1024 * 1024;

    <span class="comment">//buffer size to hold events</span>
    <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> event_buffer_size = 10*10000;
</pre></div><p>The frontend code under VxWorks uses the following sizes to accomodate the fragmented events: </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> max_event_size = 10000; <span class="comment">/* maximum size of event fragments */</span>

    <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> max_event_size_frag = 4300000  ; <span class="comment">/* maximum size of event (assembled from fragments) */</span>

    <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> event_buffer_size = 2*10000; <span class="comment">/* buffer size to hold events; must be  &gt;= 2*max_event_size  */</span>
</pre></div><ul>
<li>The value of <b>max_event_size</b> is set much smaller than the standard size, and determines the size of the event fragments.</li>
<li>The maximum size of the final event is given by <b>max_event_size_frag</b>.</li>
</ul>
<h3><a class="anchor" id="FE_frag_readout_code">
Readout routine for fragmented event</a></h3>
<p>The readout routine packs the event into <a class="el" href="FE_bank_construction.html">Midas data banks</a>, and is no different to a readout routine for a non-fragmented event. Sending the event as fragments and reassembling it is transparent to the user, as it is handled by the system routine <a class="el" href="mfe_8c.html">mfe.c</a> .</p>
<div class="fragment"><pre class="fragment"><a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> histo_read (<span class="keywordtype">char</span> *pevent, <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> off)
{
  <a class="code" href="sis3801_8h.html#a408a2366473807fbe658ba18e75dea66">DWORD</a> *pdata, *pmem;
  <a class="code" href="sis3803_8h.html#a09fddde158a3a20bd2dcadb609de11dc">INT</a> i;
  <span class="keywordtype">char</span> hist_name[10];
  <a class="code" href="sis3801_8h.html#a408a2366473807fbe658ba18e75dea66">DWORD</a> offset; <span class="comment">/* offset in words into HM */</span>

  <span class="comment">/* init bank structure */</span>
  <a class="code" href="group__bkfunctionc.html#gae7cbf587db63fcdf66dd18b29f08b6d2">bk_init32</a>(pevent);

  <span class="keywordflow">for</span> (i=0; i&lt;max_channels; i++)   <span class="comment">/* for each histogram */</span>

  {
    sprintf(hist_name, <span class="stringliteral">&quot;HI%02d&quot;</span>, i);
    offset = HM_word_offset[i]; <span class="comment">/* find offset into HM for this histo */</span>

    <span class="comment">/* create HIxx bank */</span>

      <a class="code" href="group__bkfunctionc.html#ga4bb781187e18834136ed8ac368d53413">bk_create</a>(pevent, hist_name , <a class="code" href="group__mdefineh.html#gafed9e8d519719d7347f9fdb3031201d1">TID_DWORD</a>, &amp;pdata);
      pmem = pmemBase + offset; <span class="comment">/* add offset */</span>



      <span class="comment">/* send out the number of bins requested */</span>
      memcpy(pdata, pmem, number_of_bins * <span class="keyword">sizeof</span>(<a class="code" href="sis3801_8h.html#a408a2366473807fbe658ba18e75dea66">DWORD</a>));
      pdata +=  number_of_bins; <span class="comment">/* do not cast no. bins! */</span>
     
      <a class="code" href="group__bkfunctionc.html#ga132dc71c8f74b478cdcc59bc1d9f6a26">bk_close</a>(pevent, pdata);
    
  } <span class="comment">/* end of loop on all channels (histograms) */</span>

  <span class="keywordflow">return</span> <a class="code" href="group__bkfunctionc.html#ga8fc93de36e62c4328cb6581be7f42a0f">bk_size</a>(pevent);
}
</pre></div><p><a class="anchor" id="idx_event_manual-trigger_client"></a> </p>
<h3><a class="anchor" id="FE_backend_Manual_Trigger">
A Client that Manually Triggers the Equipment</a></h3>
<p>If the frontend equipment declares a <b>Manual Trigger</b>, in addition to the event being triggered by pressing a button on the web interface, a <b>backend program can be used to trigger the event</b>. <br/>
 In the case of the <a class="el" href="FE_eq_event_routines.html#FE_manual_trigger">example above</a> where a PPC acts as a Histogramming Memory (HM), a <b> custom data logger </b> is used to save the contents of the HM periodically during the run, to guard against data loss in the event of failure, and to allow an analyzer to display the histograms during the run. At the end of run (and on Pause/Continue transitions) the Histo event is sent automatically due to the <a class="el" href="FE_eq_event_routines.html#FE_tdmusr_equipment">Equipment flags</a> RO_PAUSE, RO_CONTINUE and RO_EOR. <br/>
 During the run, when it is time to save the contents of the HM, the custom data logger needs to send a manual trigger in order to request a histogram event. This is done by with the Midas library call rpc_client_call in the function "trigger_histo_event" below. The main program uses the Midas library call bm_request_event to place an event request for the desired Histo event(event ID = 2). The following code illustrates the technique:</p>
<div class="fragment"><pre class="fragment"><span class="comment">/*-------- Custom data logger code fragment  ------------------*/</span>

<span class="keywordtype">int</span> <a class="code" href="mfe_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> argc,<span class="keywordtype">char</span> **argv)
{

   ............
   <span class="comment">/* connect to experiment */</span>
   status = <a class="code" href="group__cmfunctionc.html#ga1e96495bb5b89e4ea770a1ea7bc7787b">cm_connect_experiment</a>(<a class="code" href="mfe_8c.html#af65cc3664520b7cd0817adc7106f9624">host_name</a>, <a class="code" href="mevb_8c.html#a72ed5035970a7c95a9a3e9faeb64cc1c">expt_name</a>, ClientName, 0);

   <span class="comment">/* turn on message display, turn on message logging */</span>
    <a class="code" href="group__msgfunctionc.html#gafe6ff62436845805cd87a7ea1bd3b4dd">cm_set_msg_print</a>(<a class="code" href="group__mdefineh.html#ga3378bf6f53a24392145df33c8acc9c0c">MT_ALL</a>, <a class="code" href="group__mdefineh.html#ga3378bf6f53a24392145df33c8acc9c0c">MT_ALL</a>, msg_print);

 
   <span class="comment">/* set the buffer cache size */</span>
    <a class="code" href="group__bmfunctionc.html#ga2689ca85c6d0023f1a02e6827a5eff6e">bm_set_cache_size</a>(hBufEvent, 100000, 0);

   <span class="comment">/* TD-MUSR uses fragmented events so needs GET_ALL  */</span>
   <a class="code" href="group__bmfunctionc.html#gabf663d96482aeede1846487a7ada8184">bm_request_event</a>(hBufEvent, 2, <a class="code" href="group__mdefineh.html#ga26aa4bcea89857cb7ca669339695ceac">TRIGGER_ALL</a>, <a class="code" href="group__mdefineh.html#ga16218704fdf35f7624064c9d1d4bc78f">GET_ALL</a>, &amp;request_id, process_event_TD);

   .....................
   .....................
}
</pre></div><p>When it is time to save the data during the run, the funtion below (trigger_histo_event) is called:</p>
<div class="fragment"><pre class="fragment"><span class="comment">/*-----------------------------------------------------------------------------------------------*/</span>
<a class="code" href="vt2_8h.html#a239c7f0d40651c3e419c5b9651507d14">BOOL</a> trigger_histo_event(<span class="keywordtype">void</span>)
<span class="comment">/*-----------------------------------------------------------------------------------------------*/</span>
{
  HNDLE hconn;
  <a class="code" href="vt2_8h.html#a239c7f0d40651c3e419c5b9651507d14">BOOL</a> event_triggered;

  event_triggered = FALSE;

  ...................

  <span class="keywordflow">if</span> (<a class="code" href="mfe_8c.html#a81f01ccafac403262a2e430c118516a3">run_state</a> == <a class="code" href="group__mdefineh.html#gac4c0304c569818c811515e24523c3150">STATE_RUNNING</a>)
    {
     <span class="comment">// Check the frontend client exists</span>
     <span class="keywordflow">if</span>( <a class="code" href="group__cmfunctionc.html#gafb034d850f13190ba256f235fcea5298">cm_exist</a>(ClientName,TRUE))      
        { 
          status = <a class="code" href="group__cmfunctionc.html#ga6a8a21234c7ce94bdf26bbcbcf778a39">cm_connect_client</a> (ClientName, &amp;hconn);
          <span class="keywordflow">if</span>(status != <a class="code" href="group__err25.html#ga19b06966ce058cda8e5dca8d682b2bd3">RPC_SUCCESS</a>)
            <a class="code" href="group__msgfunctionc.html#gaac032ca2438c47466bfc9722de6746ea">cm_msg</a>(<a class="code" href="group__mdefineh.html#gac2d967025ca0f84f611d568f4ede934a">MERROR</a>,<span class="stringliteral">&quot;trigger_histo_event&quot;</span>,<span class="stringliteral">&quot;Cannot connect to frontend \&quot;%s\&quot; (%d)&quot;</span>,
                   ClientName,status);
      <span class="keywordflow">else</span>      
         {  <span class="comment">// successfully connected to frontend client</span>
            rpc_client_call(hconn, <a class="code" href="group__mrpcdefineh.html#gaf820c7d84c71a1469983d23ebec18a8f">RPC_MANUAL_TRIG</a>, 2); <span class="comment">// trigger a histo event</span>
            <span class="keywordflow">if</span> (status != <a class="code" href="group__err21.html#ga0180947941230d805f5dbb6f1801c17c">CM_SUCCESS</a>)
              <a class="code" href="group__msgfunctionc.html#gaac032ca2438c47466bfc9722de6746ea">cm_msg</a>(<a class="code" href="group__mdefineh.html#gac2d967025ca0f84f611d568f4ede934a">MERROR</a>,<span class="stringliteral">&quot;trigger_histo_event&quot;</span>,<span class="stringliteral">&quot;Error triggering event from frontend (%d)&quot;</span>,status);
            <span class="keywordflow">else</span>
              {  <span class="comment">// successfully triggered event</span>
                event_triggered=TRUE;
                status =<a class="code" href="group__cmfunctionc.html#ga084b807db46901ac411824a94f59645d">cm_disconnect_client</a>(hconn, FALSE);
                <span class="keywordflow">if</span> (status != <a class="code" href="group__err21.html#ga0180947941230d805f5dbb6f1801c17c">CM_SUCCESS</a>)
                  <a class="code" href="group__msgfunctionc.html#gaac032ca2438c47466bfc9722de6746ea">cm_msg</a>(<a class="code" href="group__mdefineh.html#gac2d967025ca0f84f611d568f4ede934a">MERROR</a>,<span class="stringliteral">&quot;trigger_histo_event&quot;</span>,<span class="stringliteral">&quot;Error disconnecting client after event trigger(%d)&quot;</span>,status)
;
              }
          }
       } <span class="comment">// end of cm_exist</span>
      <span class="keywordflow">else</span>
        <a class="code" href="group__msgfunctionc.html#gaac032ca2438c47466bfc9722de6746ea">cm_msg</a>(<a class="code" href="group__mdefineh.html#gac2d967025ca0f84f611d568f4ede934a">MERROR</a>,<span class="stringliteral">&quot;trigger_histo_event&quot;</span>,<span class="stringliteral">&quot;Frontend client %s not running; not triggering an event (%d)&quot;</span>,
               ClientName,status);
    } <span class="comment">// end of if running</span>
  <span class="keywordflow">return</span>(event_triggered);
}
</pre></div><p> <br/>
 <br/>
  
<script type="text/javascript">
pages( "FE_sequence", "FrontendOperation",  "FE_event_notification","FE_eq_event_routines","" ); // back index next {top bottom}
// section parameters: last section; top of this section; next section
sections("RunControl","FrontendOperation","DataAnalysis");
</script>
 <br/>
 <a class="anchor" id="end"></a> </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<br>
<hr WIDTH="100%">
Midas DOC Version 2.3.0&nbsp;----&nbsp;PSI Stefan Ritt&nbsp;----
<br>
Contributions: Pierre-Andre Amaudruz - Sergio Ballestrero - Suzannah Daviel -
<a href=http://www.stack.nl/~dimitri/doxygen/features.html>Doxygen</a> - Peter Green -
Qing Gu - Greg Hackman - Gertjan Hofman - Paul Knowles - Exaos Lee - Rudi Meier - Glenn
Moloney - Dave Morris - John M O'Donnell - Konstantin Olchanski - Chris Pearson - Renee Poutissou
- Tamsen Schurman - Andreas Suter - Jan M.Wouters - Piotr Adam Zolnierczuk
<hr WIDTH="100%">

