\subsubsection{Data formats written by the frontend}\label{FE_Data_format}
\par




\par
 \par
 \label{FE_Data_format_idx_format_frontend}
\hypertarget{FE_Data_format_idx_format_frontend}{}
 Only two formats are now now supported by the frontend, \hyperlink{FE_Data_format_FE_Midas_format}{MIDAS} and \hyperlink{FE_bank_construction_FE_FIXED_event_readout}{FIXED} (support for YBOS format has been discontinued (\hyperlink{NDF_ndf_sep_2010}{Sep 2010}). \hyperlink{FE_bank_construction_FE_MIDAS_event_construction}{MIDAS event construction} has been described previously. This section gives a detailed description of the MIDAS format.

Note that a frontend cannot write data directly into ROOT format. A conversion to ROOT may be done (e.g. by the data logger) from one of the supported formats (see \hyperlink{FE_table_FE_tbl_Format}{equipment list} for details).

\label{FE_Data_format_idx_format_MIDAS}
\hypertarget{FE_Data_format_idx_format_MIDAS}{}
 \label{FE_Data_format_idx_Midas_format}
\hypertarget{FE_Data_format_idx_Midas_format}{}
 \label{FE_Data_format_Midas_format}
\hypertarget{FE_Data_format_Midas_format}{}
 

 \hypertarget{FE_Data_format_FE_Midas_format}{}\subsubsection{MIDAS format}\label{FE_Data_format_FE_Midas_format}
Special formats are used in MIDAS for the event header, banks and when writing to disk or tape. This section explains these formats in detail. Each event carries a 16-\/byte header. The header is generated by the front-\/end with the \hyperlink{group__bmfunctionc_gac5e3e469fb6721a502ebd80a35a328f5}{bm\_\-compose\_\-event()} routine and is used by consumers to distinguish between different events. The header is defined in the \hyperlink{structEVENT__HEADER}{EVENT\_\-HEADER} structure in \hyperlink{midas_8h}{midas.h}. It has following structure:

\begin{center} Figure 1: Event and bank headers with data block.  \end{center} 


\begin{DoxyItemize}
\item The \hyperlink{FE_table_FE_tbl_EventID}{event ID} describes the type of event. Usually 1 is used for triggered events, 2 for scaler events, 3 for HV events etc.
\item The \hyperlink{FE_table_FE_tbl_TrigMask}{trigger mask} can be used to describe the sub-\/type of an event. A trigger event can have different trigger sources like \char`\"{}physics event\char`\"{}, \char`\"{}calibration event\char`\"{}, \char`\"{}clock event\char`\"{}. These trigger sources are usually read in by the front-\/end in a pattern unit. Consumers can request events with a specific triggering mask.
\item The {\bfseries serial number} starts at 1 and is incremented by the front-\/end for each event.
\item The {\bfseries time stamp} is written by the front-\/end before an event is read out. It uses the time() function which returns the time in seconds since 1.1.1970 00:00:00 UTC.
\item The {\bfseries data size} contains the number of bytes that follows the event header.
\item The {\bfseries data area} of the event can contain information in any user format (integer, real etc.), although only certain formats are supported when events are copied to the ODB or written by the logger in ASCII format.
\end{DoxyItemize}

\label{FE_Data_format_idx_byte-ordering}
\hypertarget{FE_Data_format_idx_byte-ordering}{}
 Event headers are always kept in the {\bfseries byte ordering} of the local machine. If events are sent over the network between computers with different byte ordering, the event header is swapped automatically, but not the event contents.\hypertarget{FE_Data_format_FE_Bank_Format}{}\paragraph{Bank Format}\label{FE_Data_format_FE_Bank_Format}
Events in MIDAS format contain \char`\"{}MIDAS banks\char`\"{}. A bank is a substructure of an event and can contain only one type of data, either a single value or an array of values. Banks have a name of exactly four characters, which are treated as a {\bfseries bank ID}. Banks in an event consist of a {\bfseries global} bank header and an {\bfseries individual} bank header for each bank.

Figure 2 shows a MIDAS event containing banks coloured to match the structure in Figure 1. This has been obtained from a MIDAS data file using the \hyperlink{RC_Monitor_RC_mdump_utility}{mdump utility}.

\par
\par
  Figure 2: Example of MIDAS banks dumped by mdump. \par
 -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ Event\# 2 -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/\par
 Evid:000d-\/ Mask:0000-\/ Serial:0-\/ Time:0x4c7a6869-\/ Dsize:48/0x30\par
 \#banks:1 -\/ Bank list:-\/SDAS-\/\par
 \par
 Bank:SDAS Length: 32(I$\ast$1)/8(I$\ast$4)/8(Type)Type:Real$\ast$4 (FMT machine dependent)\par
  1-\/$>$ 4.000e+00 1.000e+01 1.000e+00 3.400e+00 3.400e+00 3.400e+00 3.400e+00 3.400e+00\par
 \par
 -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ Event\# 3 -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/\par
 Evid:0001-\/ Mask:0000-\/ Serial:0-\/ Time:0x4c7a686b-\/ Dsize:344/0x158\par
 \#banks:2 -\/ Bank list:-\/MPETMCPP-\/\par
 \par
 Bank:MPET Length: 304(I$\ast$1)/76(I$\ast$4)/76(Type) Type:Unsigned Integer$\ast$4\par
  1-\/$>$ 0x80010000 0x00000002 0x10010000 0x00004e21 0x80020000 0x00000002 0x20020000 0x000015f4\par
 9-\/$>$ 0x20020000 0x00001660 0x20020000 0x0000185f 0x20020000 0x0000191e 0x20020000 0x000019d6\par
 17-\/$>$ 0x40020000 0x00001a37 0x20020000 0x00001a77 0x20020000 0x00001ba2 0x10020000 0x00004e22\par
 25-\/$>$ 0x80030000 0x00000002 0x20030000 0x00001637 0x20030000 0x000018d1 0x20030000 0x000019bc\par
 33-\/$>$ 0x20030000 0x00001b35 0x20030000 0x00001bb2 0x10030000 0x00004e21 0x80040000 0x00000002\par
 41-\/$>$ 0x10040000 0x00004e22 0x80050000 0x00000002 0x20050000 0x000013c5 0x20050000 0x000017f2\par
 49-\/$>$ 0x20050000 0x0000185f 0x20050000 0x00001976 0x20050000 0x00001aa8 0x10050000 0x00004e21\par
 57-\/$>$ 0x80060000 0x00000002 0x20060000 0x000015c3 0x20060000 0x000018d8 0x20060000 0x0000198d\par
 65-\/$>$ 0x20060000 0x00001ac4 0x10060000 0x00004e22 0x80070000 0x00000002 0x20070000 0x00001747\par
 73-\/$>$ 0x20070000 0x000019ae 0x10070000 0x00004e21\par
 \par
 Bank:MCPP Length: 16(I$\ast$1)/4(I$\ast$4)/4(Type) Type:Unsigned Integer$\ast$4\par
  1-\/$>$ 0x00005e4c 0x0000352d 0x00006453 0x00006d5b\par
 \par


The \char`\"{}data size total\char`\"{} is the size in bytes of all bank headers and bank data. Flags are currently not used. The bank header contains four characters as identification, a bank type that is one of the TID\_\-xxx values defined in \hyperlink{midas_8h}{midas.h}, and the data size in bytes. If the byte ordering of the contents of a complete event has to be swapped, the routine \hyperlink{group__bkfunctionc_ga44b7381af9b91fbdf2f6d59f55451ea1}{bk\_\-swap()} can be used.

\par


\par
 \label{FE_Data_format_idx_format_Midas_Tape}
\hypertarget{FE_Data_format_idx_format_Midas_Tape}{}
 \hypertarget{FE_Data_format_Tape}{}\paragraph{Format}\label{FE_Data_format_Tape}
Events are written to disk files without any reformatting. For tapes, however, a fixed block size is used. The block size TAPE\_\-BUFFER\_\-SIZE is defined in \hyperlink{midas_8h}{midas.h} and usually 32kB. Three special events are produced by the system. A begin-\/of-\/run (BOR) and end-\/of-\/run (EOR) event is produced which contains an ASCII dump of the ODB in its data area. Their IDs is 0x8000 (BOR) and 0x8001 (EOR). A message event (ID 0x8002) is created if Log messages is enabled in the logger channel setting. The message is contained in the data area as an ASCII string. The BOR event has the number MIDAS\_\-MAGIC (0x494d or 'MI') as the trigger mask and the current run number as the serial number. A tape can therefore be identified as a MIDAS formatted tape. The routine tape\_\-copy() in the utility mtape.c is an example of how to read a tape in MIDAS format.

\label{index_end}
\hypertarget{index_end}{}


\par




\par
 \subsubsection{Supported Hardware: MIDAS driver library}\label{FE_Hardware}
\par
 

\label{FE_Hardware_idx_Hardware_driver_library}
\hypertarget{FE_Hardware_idx_Hardware_driver_library}{}


The driver library is continuously extended to suit the needs of various experiments based on the selected hardware modules. Not all commercially available modules are included as we don't have all the modules in hand. But you're more than welcome to contribute by providing your driver code if the module that you're using is not yet listed.

The {\bfseries /drivers} directory is subdivided in several directories which refers to either the type of bus ie: CAMAC, FastBus, VME, PCI, USB or type of software layer such as Class, Device, Bus.

The software layers sections are used in particular for \hyperlink{FE_Slow_Control_system}{Slow Control System}. Example are available in the distribution under {\bfseries examples/slowcont/frontend.c} including the {\bfseries hv} and {\bfseries multi} class with the {\bfseries nulldev} device and {\bfseries null} bus driver. Note: not all the device drivers implement the triple layer (Class,Device,Bus) as some include directly the hardware calls in the device layer. Please contact \href{mailto:midas@psi.ch, midas@triumf.ca?subject=VME support}{\tt midas} for specific support or for submitting new drivers.

\begin{center} Non exhaustive Drivers/ directory structure  \end{center} 


\begin{DoxyItemize}
\item \hyperlink{FE_Hardware_CAMAC_drivers}{CAMAC drivers} This section is slowly getting obsolete. But still some ISA and PCI interface are in use. Most recent development is the USB/CAMAC interface from Wiener (\href{http://www.wiener-d.com/M/17/7.html}{\tt CCUSB}). While this interface permits {\bfseries CAMAC Command Stacks} this option is not yet supported by the MIDAS API limiting the access speed of a R/W 24bit cycle to $\sim$360us!
\end{DoxyItemize}


\begin{DoxyItemize}
\item \hyperlink{FE_Hardware_VME_drivers}{VME drivers} The VME API has been revisited for a better function call set. Not all the hardware modules have been ported to this new scheme. DMA and Interrupt support have been included. The main hardware support is for the SBS PCI/VME, SIS PCI/VME, VMIC processor.
\end{DoxyItemize}


\begin{DoxyItemize}
\item \hyperlink{FE_Hardware_USB_drivers}{USB drivers} USB is getting popular in particular for the \href{http://midas.psi.ch/mscb/}{\tt MSCB} system. Following the same concept as for the CAMAC and VME, the {\bfseries musbstd.h/c} is available for USB access.
\end{DoxyItemize}


\begin{DoxyItemize}
\item \hyperlink{FE_Hardware_GPIB_drivers}{GPIB drivers}
\end{DoxyItemize}


\begin{DoxyItemize}
\item \hyperlink{FE_Hardware_Other_drivers}{Other drivers} This include the TCP/IP, Serial access layer.
\end{DoxyItemize}

\label{FE_Hardware_idx_Hardware_drivers_CAMAC}
\hypertarget{FE_Hardware_idx_Hardware_drivers_CAMAC}{}
 

 \hypertarget{FE_Hardware_CAMAC_drivers}{}\subsubsection{CAMAC drivers}\label{FE_Hardware_CAMAC_drivers}
The CAMAC drivers can be used in different configuration and may have special behaviors depending on the type of hardware involved. Below are summurized some remarks about these particular hardware modules.


\begin{DoxyItemize}
\item CAMAC controllers
\begin{DoxyItemize}
\item {\bfseries }\mbox{[}hyt1331.c\mbox{]} This interface uses an ISA board to connect to the crate controller. This card implement a \char`\"{}fast\char`\"{} readout cycle by re-\/triggering the CAMAC read at the end of the previous one. This feature is unfortunately not reliable when fast processor is used. Wrong returned data can be expected when CPU clocks is above 250MHz. Attempt on \char`\"{}slowing down\char`\"{} the IO through software has not guaranteed perfect result. Contact has been taken with HYTEC in order to see if possible fix can be applied to the interface. First revision of the PC-\/card PAL has been tested but did not show improvement. CVS version of the hyt1331.c until 1.2 contains \char`\"{}fast readout
  cycle\char`\"{} and should not be trusted. CVS 1.3 driver revision contains a patch to this problem. In the mean time you can apply your own patch (see \hyperlink{FAQ}{SECTION 12: Frequently Asked Questions}) and also \href{http://www.hytec-electronics.co.uk/index.html}{\tt Hytec })
\item {\bfseries  \mbox{[}hyt1331.c Version $>$= 1.8.3\mbox{]}} This version has been modified for 5331 PCI card support running under the \hyperlink{FE_utils_FE_dio_utility}{dio -\/ direct I/O driver}.
\item {\bfseries \mbox{[}khyt1331.c Version $>$= 1.8.3\mbox{]}} A full Linux driver is available for the 5331 PCI card interfacing to the hyt1331. The kernel driver has been written for the Linux kernel 2.4.2, which comes with RedHat 7.1. It could be ported back to the 2.2.x kernel because no special feature of 2.4.x are used, although many data structures and function \hyperlink{structparameters}{parameters} have changed between 2.2 and 2.4, which makes the porting a bit painful. The driver supports only one 5331 card with up to four CAMAC crates.
\item {\bfseries \mbox{[}kcs292x.c\mbox{]}} The 2926 is an 8 bit ISA board, while the 2927 is a 16bit ISA board. An equivalent PCI interface (2915) exists but is not yet supported by MIDAS (See \href{http://www.kscorp.com/www/camac/1000/2915.html}{\tt KCS}). No support for Windowx yet. \par
\par
 Both cards can be used also through a proper Linux driver {\itshape camaclx.c\/}. This requires to first load a module {\itshape camac-\/kcs292x.o\/}. This software is available but not part of the MIDAS distribution yet. Please contact \href{mailto:midas@triumf.ca?subject=KCS driver}{\tt midas} for further information. \par
\par

\item {\bfseries \mbox{[}wecc32.c\mbox{]}} The CAMAC crate controller CC32 interface to a PCI card... you will need the proper Linux module... Currently under test. WindowsNT and W95 drivers available but not implemented under MIDAS. (see \href{http://www.wiener-d.com/cc32.htm}{\tt CC32})
\item {\bfseries \mbox{[}dsp004.c\mbox{]}} The dsp004 is an 8 bit ISA board PC interface which connect to the PC6002 CAMAC crate controller. This module is not being manufactured anymore, but somehow several labs still have that controller in use.
\item {\bfseries \mbox{[}ces8210.c\mbox{]}} The CAMAC crate controller CBD8210 interface is a VME module to give access up to 7 CAMAC crate. In conjunction with the \hyperlink{mvmestd_8h}{mvmestd.h} and \hyperlink{mcstd_8h}{mcstd.h}, this driver can be used on any MIDAS/VME interface.
\item {\bfseries \mbox{[}jorway73a.c\mbox{]}} The CAMAC crate controller Jorway73a is accessed through SCSI commands. This driver implement the \hyperlink{mcstd_8h}{mcstd.h} calls.
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyItemize}
\item CAMAC drivers
\begin{DoxyItemize}
\item {\bfseries }\mbox{[}camacnul.c\mbox{]} Handy fake CAMAC driver for code development.
\item {\bfseries }\mbox{[}camacrpc.c\mbox{]} Remote Procedure Call CAMAC driver used for accessing the CAMAC server part of the standard MIDAS frontend code. This driver is used for example in the \hyperlink{FE_utils_FE_mcnaf_utility}{mcnaf} and \hyperlink{RC_mhttpd_utility}{mhttpd} utilities.
\end{DoxyItemize}
\end{DoxyItemize}

\label{FE_Hardware_idx_Hardware_drivers_VME}
\hypertarget{FE_Hardware_idx_Hardware_drivers_VME}{}
 

 \hypertarget{FE_Hardware_VME_drivers}{}\subsubsection{VME drivers}\label{FE_Hardware_VME_drivers}
The VME modules drivers can be interfaced to any type of PCI/VME controller. This is done by dedicated MIDAS VME Standard calls from the \hyperlink{mvmestd_8h}{mvmestd.h} files.


\begin{DoxyItemize}
\item PCI/VME interface
\begin{DoxyItemize}
\item {\bfseries }\mbox{[}sis1100.c\mbox{]} PCI/VME with optical fiber link. Driver is under development (March 2002). (see \href{http://www.sruck.de/vme.htm}{\tt SIS}).
\item {\bfseries }\mbox{[}bt617.c\mbox{]} Routines for accessing VME over SBS Bit3 Model 617 interface under Windows NT using the NT device driver Model 983 and under Linux using the vmehb device driver. The VME calls are implemented for the \char`\"{}mvmestd\char`\"{} MIDAS VME Standard. (see \href{http://www.sbs.com/computer/products/cp_adapters.shtml}{\tt Bit3}).
\item {\bfseries }\mbox{[}wevmemm.c\mbox{]} PCI/VME Wiener board supported. (see \href{http://www.wiener-d.com/vmepci.htm}{\tt Wiener PCI}).
\item \mbox{[}vxVME.c\mbox{]} mvmestd implementation for VxWorks Operating System. Does require cross compiler for the VxWorks target hardware processor and proper WindRiver license.
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyItemize}
\item VME modules
\begin{DoxyItemize}
\item {\bfseries }\mbox{[}\hyperlink{lrs1190_8c}{lrs1190.c}\mbox{]} LeCroy Dual-\/port memory ECL 32bits.
\item {\bfseries }\mbox{[}\hyperlink{lrs1151_8c}{lrs1151.c}\mbox{]} LeCroy 16 ECL 32bits scalers.
\item {\bfseries }\mbox{[}lrs2365.c\mbox{]} LeCroy Logic matrix.
\item {\bfseries }\mbox{[}lrs2373.c\mbox{]} LeCroy Memory Lookup unit.
\item {\bfseries }\mbox{[}sis3700.c\mbox{]} SIS FERA Fifo 32 bits.
\item {\bfseries }\mbox{[}\hyperlink{sis3801_8c}{sis3801.c}\mbox{]} SIS MultiChannel Scalers 32 channels.
\item {\bfseries }\mbox{[}\hyperlink{sis3803_8c}{sis3803.c}\mbox{]} SIS Standard 32 Scalers 32 bits.
\item {\bfseries }\mbox{[}ps7106.c\mbox{]} Phillips Scientific Discriminator.
\item {\bfseries }\mbox{[}ces8210.c\mbox{]} CES CAMAC crate controller.
\item {\bfseries }\mbox{[}\hyperlink{vmeio_8c}{vmeio.c}\mbox{]} Triumf VMEIO General purpose I/O 24bits.
\end{DoxyItemize}
\end{DoxyItemize}

\label{FE_Hardware_idx_Hardware_drivers_USB}
\hypertarget{FE_Hardware_idx_Hardware_drivers_USB}{}
 

 \hypertarget{FE_Hardware_USB_drivers}{}\subsubsection{USB drivers}\label{FE_Hardware_USB_drivers}
This section is under development for the Wiener USB/CAMAC CCUSB controller. Support for Linux and XP is undergo. Please contact \href{mailto:midas@psi.ch, midas@triumf.ca?subject=USB driver}{\tt midas} for further information.

\label{FE_Hardware_idx_Hardware_drivers_GPIB}
\hypertarget{FE_Hardware_idx_Hardware_drivers_GPIB}{}
 

 \hypertarget{FE_Hardware_GPIB_drivers}{}\subsubsection{GPIB drivers}\label{FE_Hardware_GPIB_drivers}
There is no specific GPIB driver part of the MIDAS package. But GPIB is used at Triumf under WindowsNT for several Slow Control frontends. The basic GPIB DLL library is provided by \href{http://www.ni.com/default.htm}{\tt National Instrument}. Please contact \href{mailto:midas@triumf.ca?subject=GPIB driver}{\tt midas} for further information.

For GPIB Linux support please refer to \href{http://www.llp.fu-berlin.de/pool/software/busses/}{\tt The Linux Lab Project}

\label{FE_Hardware_idx_Hardware_drivers_other}
\hypertarget{FE_Hardware_idx_Hardware_drivers_other}{}
 

 \hypertarget{FE_Hardware_Other_drivers}{}\subsubsection{Other drivers}\label{FE_Hardware_Other_drivers}

\begin{DoxyItemize}
\item {\bfseries \mbox{[}Serial driver\mbox{]}} rs232.c communication routines.
\item {\bfseries \mbox{[}Network driver\mbox{]}} {\bfseries tcpip.c/h} TCP/IP socket communication routines.
\item {\bfseries \mbox{[}SCSI driver\mbox{]}} Support for the jorway73a SCSI/CAMAC controller under Linux has been done by Greg Hackman (see \hyperlink{FE_Hardware_CAMAC_drivers}{CAMAC drivers}).
\end{DoxyItemize}

\par
 \par


 \par
 \label{index_end}
\hypertarget{index_end}{}
 \subsubsection{CAMAC and VME access function calls}\label{FE_camac_vme_function_calls}
\par
 

\par
 \label{FE_camac_vme_function_calls_idx_hardware_standard_interface}
\hypertarget{FE_camac_vme_function_calls_idx_hardware_standard_interface}{}
 MIDAS defines its own set of CAMAC and VME calls in order to unify the different hardware modules that it supports. This interface method permits code to be totally {\itshape  hardware as well as OS independent \/}. For example, the same user code developed on a system can be used as a template for another application on a different operating system.

MIDAS provides {\bfseries Standard} {\bfseries Interfaces} for VME and CAMAC
\begin{DoxyItemize}
\item {\bfseries \hyperlink{mcstd_8h}{mcstd.h}} for {\bfseries CAMAC} access
\item {\bfseries \hyperlink{mvmestd_8h}{mvmestd.h}} for {\bfseries VME} access
\end{DoxyItemize}

An extra CAMAC interface built on top of {\bfseries mcstd} provides the ESONE standard CAMAC calls (\hyperlink{esone_8c}{esone.c}).

Refer to the corresponding directories under \$(\hyperlink{BuildingOptions_BO_MIDASSYS}{MIDASSYS}){\itshape /drivers\/} to find out what module of each family is already supported by the current MIDAS distribution. The directory \$(\hyperlink{BuildingOptions_BO_MIDASSYS}{MIDASSYS}){\itshape /drivers/divers\/} contains older drivers which have not yet been converted to the latest API.

\label{FE_camac_vme_function_calls_idx_hardware_standard_interface_CAMAC}
\hypertarget{FE_camac_vme_function_calls_idx_hardware_standard_interface_CAMAC}{}
 

 \hypertarget{FE_camac_vme_function_calls_FE_Midas_CAMAC_standard_functions}{}\subsubsection{MIDAS CAMAC standard functions}\label{FE_camac_vme_function_calls_FE_Midas_CAMAC_standard_functions}
Please refer to \hyperlink{group__mcstdfunctionh}{Camac Functions (camxxx)} for function description.

\label{FE_camac_vme_function_calls_idx_hardware_CAMAC_functions_ESONE}
\hypertarget{FE_camac_vme_function_calls_idx_hardware_CAMAC_functions_ESONE}{}
 

 \hypertarget{FE_camac_vme_function_calls_FE_ESONE_CAMAC_standard_functions}{}\subsubsection{ESONE CAMAC standard functions}\label{FE_camac_vme_function_calls_FE_ESONE_CAMAC_standard_functions}
{\bfseries Not all the functionality of ESONE standard has been fully tested}

Please refer to \hyperlink{group__mesonefunctionc}{Camac Functions (Esone)} for function description.

\label{FE_camac_vme_function_calls_idx_hardware_standard_interface_VME}
\hypertarget{FE_camac_vme_function_calls_idx_hardware_standard_interface_VME}{}
 

 \hypertarget{FE_camac_vme_function_calls_FE_Midas_VME_standard_functions}{}\subsubsection{MIDAS VME standard functions}\label{FE_camac_vme_function_calls_FE_Midas_VME_standard_functions}
This API provides basic VME access through a {\bfseries simple} set of functions. Refer to \hyperlink{group__mvmestdfunctionh}{VME Functions (mvme\_\-xxx)} for more specific information. \hyperlink{group__mvmestdfunctionh_ga13db7fc7c7c022e46fadd8fc4dc40047}{mvme\_\-open()} contains a general access code sample summarizing most of the mvme commands.

\label{FE_camac_vme_function_calls_idx_hardware_computer-busy}
\hypertarget{FE_camac_vme_function_calls_idx_hardware_computer-busy}{}
 

 \hypertarget{FE_camac_vme_function_calls_FE_Compute_Busy_Logic}{}\subsubsection{Computer Busy Logic}\label{FE_camac_vme_function_calls_FE_Compute_Busy_Logic}
A \char`\"{}computer busy logic\char`\"{} has to be implemented for a front-\/end to work properly. The reason for this is that some ADC modules can be re-\/triggered. If they receive more than one gate pulse before being read out, they accumulate the input charge that leads to incorrect results. Therefore only one gate pulse should be sent to the ADCs, and additional pulses must be blocked before the event is read out by the front-\/end. This operation is usually performed by a latch module, which is set by the trigger signal and reset by the computer after it has read out the event.

The output of this latch is shaped (limited in its pulse width to match the ADC gate width) and distributed to the ADCs. This scheme has two problems. The computer generates the reset signal, usually by two CAMAC output functions to a CAMAC IO unit. Therefore the duration of the pulse is a couple of ms. There is a non-\/negligible probability that during the reset pulse there is another hardware trigger. If this happens and both inputs of the latch are active, its function is undefined. Usually it generates several output pulses that lead to erroneous ADC values. The second problem lies in the fact that the latch can be just reset when a trigger input is active. This can happen since trigger signals usually have a width of a few tens of nanoseconds. In this case the latch output signal does not carry the timing of the trigger signal, but the timing of the reset signal. The incorrect timing of the output can lead to false ADC and TDC signals. To overcome this problem, a more elaborate scheme is necessary. One possible solution is the use of a latch module with edge-\/sensitive input and veto input. At PSI, the module \char`\"{}D. TRIGGER / DT102\char`\"{} can be used. The veto input is also connected to the computer:

\begin{center} Latched trigger layout.  \end{center} 

To reset this latch, the following bit sequence is applied to the computer output (signals are displayed active low):

\begin{center} Improved Latched trigger layout.  \end{center} 

The active veto signal during the reset pulse avoids the case where the latch can receive a \char`\"{}set\char`\"{} and a \char`\"{}reset\char`\"{} simultaneously. The edge-\/sensitive input ensures that the latch can only trigger on a leading edge of a trigger signal, and not when the veto signal is removed. This ensures that the timing of the trigger is always carried at the ADC/TDC gate signal.

\begin{center} Veto Timing.  \end{center} 

\par
 

\par
 \label{index_end}
\hypertarget{index_end}{}
 \subsubsection{Hardware Access utilities}\label{FE_utils}
\par
 

\par



\begin{DoxyItemize}
\item \hyperlink{FE_utils_FE_mcnaf_utility}{mcnaf -\/ CAMAC hardware access}
\item \hyperlink{FE_utils_FE_dio_utility}{dio -\/ direct I/O driver}
\end{DoxyItemize}\hypertarget{FE_utils_FE_mcnaf_utility}{}\subsubsection{mcnaf        -\/ CAMAC hardware access}\label{FE_utils_FE_mcnaf_utility}
{\bfseries mcnaf} is an interactive CAMAC tool which allows \char`\"{}direct\char`\"{} access to the CAMAC hardware. This application is operational under either of the two following conditions:
\begin{DoxyEnumerate}
\item {\bfseries mcnaf} has been built against a particular CAMAC driver (see \hyperlink{FE_Hardware_CAMAC_drivers}{CAMAC drivers}).
\item A user frontend code using a valid CAMAC driver is currently active. In this case the frontend acts as a RPC CAMAC server and will handle the CAMAC request. This last option is only available if the frontend code (\hyperlink{mfe_8c}{mfe.c}) from the \hyperlink{BuildingOptions_BO_building_option}{Building Options} has included the \hyperlink{BuildingOptions_BO_HAVE_CAMAC}{HAVE\_\-CAMAC} pre-\/compiler flag.
\end{DoxyEnumerate}


\begin{DoxyItemize}
\item {\bfseries  Arguments }
\begin{DoxyItemize}
\item \mbox{[}-\/h \mbox{]} : help
\item \mbox{[}-\/h hostname \mbox{]} : host name
\item \mbox{[}-\/e exptname \mbox{]} : experiment name
\item \mbox{[}-\/f frontend name\mbox{]} : Frontend name to connect to.
\item \mbox{[}-\/s RPC server name\mbox{]} : CAMAC RPC server name for remote connection.
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyItemize}
\item {\bfseries  Building application } The {\bfseries midas/utils/makefile.mcnaf} will build a collection of {\bfseries mcnaf} applications which are hardware dependent, see {\bfseries  Example } below:
\begin{DoxyItemize}
\item {\bfseries \mbox{[}miocnaf\mbox{]}} cnaf application using the declared CAMAC hardware DRIVER (kcs2927 in this case). To be used with {\bfseries dio} CAMAC application starter (see \hyperlink{FE_utils_FE_dio_utility}{dio -\/ direct I/O driver}).
\item {\bfseries \mbox{[}mwecnaf\mbox{]}} cnaf application using the WI-\/E-\/N-\/ER PCI/CAMAC interface (see \hyperlink{FE_Hardware_CAMAC_drivers}{CAMAC drivers}). Please contact: \href{mailto:midas@triumf.ca}{\tt midas@triumf.ca} for further information.
\item {\bfseries \mbox{[}mcnaf\mbox{]}} cnaf application using the CAMAC RPC capability of any MIDAS frontend program having CAMAC access.
\item {\bfseries \mbox{[}mdrvcnaf\mbox{]}} cnaf application using the Linux CAMAC driver for either kcs2927, kcs2926, dsp004. This application would require to have the proper Linux module loaded in the system first. Please contact mailto:\href{mailto:midas@triumf.ca}{\tt midas@triumf.ca} for further information.
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyCode}
Thu> cd /midas/utils
Thu> make -f makefile.mcnaf DRIVER=kcs2927
gcc -O3 -I../include -DOS_LINUX -c -o mcnaf.o mcnaf.c
gcc -O3 -I../include -DOS_LINUX -c -o kcs2927.o ../drivers/bus/kcs2927.c
gcc -O3 -I../include -DOS_LINUX -o miocnaf mcnaf.o kcs2927.o  ../linux/lib/libmid
      as.a -lutil
gcc -O3 -I../include -DOS_LINUX -c -o wecc32.o ../drivers/bus/wecc32.c
gcc -O3 -I../include -DOS_LINUX -o mwecnaf mcnaf.o wecc32.o  ../linux/lib/libmida
      s.a -lutil 
gcc -O3 -I../include -DOS_LINUX -c -o camacrpc.o ../drivers/bus/camacrpc.c
gcc -O3 -I../include -DOS_LINUX -o mcnaf mcnaf.o camacrpc.o  ../linux/lib/libmida
      s.a -lutil 
gcc -O3 -I../include -DOS_LINUX -c -o camaclx.o ../drivers/bus/camaclx.c
gcc -O3 -I../include -DOS_LINUX -o mdrvcnaf mcnaf.o camaclx.o  ../linux/lib/libmi
      das.a -lutil 
rm *.o
\end{DoxyCode}



\begin{DoxyItemize}
\item {\bfseries  Running application }
\begin{DoxyItemize}
\item Direct CAMAC access: This requires the computer to have the proper CAMAC interface installed and the {\bfseries BASE} ADDRESS matching the value defined in the corresponding CAMAC driver. For kcs2926.c, kcs2927.c, dsp004.c, hyt1331.c, the base address (CAMAC\_\-BASE) is set to 0x280. 
\begin{DoxyCode}
   >dio miocnaf
\end{DoxyCode}

\item RPC CAMAC through frontend: This requires to have a frontend running which will be able to serve the CAMAC RPC request. Any MIDAS frontend has that capability built-\/in but it has to have the proper CAMAC driver included in it. 
\begin{DoxyCode}
     >mcnaf -e <expt> -h <host> -f <fe_name>
\end{DoxyCode}

\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyItemize}
\item {\bfseries  Usage } 
\begin{DoxyCode}
  ........
\end{DoxyCode}

\end{DoxyItemize}



 \hypertarget{FE_utils_FE_dio_utility}{}\subsubsection{dio          -\/ direct I/O driver}\label{FE_utils_FE_dio_utility}
Direct I/O task provider (LINUX).

If no particular Linux driver is installed for the CAMAC access, the {\bfseries dio-\/} program will allow you to access the I/O ports to which the CAMAC interface card is connected to.


\begin{DoxyItemize}
\item {\bfseries  Arguments }
\begin{DoxyItemize}
\item \mbox{[}application name \mbox{]} : Program name requiring I/O permission.
\end{DoxyItemize}
\item {\bfseries  Usage } 
\begin{DoxyCode}
 >dio miocnaf
 >dio frontend 
\end{DoxyCode}

\item {\bfseries  Remark }
\item This \char`\"{}hacking\char`\"{} utility restricts the access to a range of I/O ports from 0x200 to 0x3FF.
\end{DoxyItemize}


\begin{DoxyItemize}
\item As this mode if I/O access by-\/passes the driver (if any), concurrent access to the same I/O port may produce unexpected result and in the worst case it will freeze the computer. It is therefore important to ensure to run one and only one dio application to a given port in order to prevent potential hangup problem.
\end{DoxyItemize}


\begin{DoxyItemize}
\item Interrupt handling, DMA capabilities of the interface will not be accessible under this mode of operation.
\end{DoxyItemize}

\label{index_end}
\hypertarget{index_end}{}
 \par


 \par
 