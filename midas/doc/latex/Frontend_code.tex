\subsubsection{Frontend Code Sections}\label{FE_code_sections}
\par
  \par
\hypertarget{FE_code_sections_FE_includes}{}\subsubsection{Include files}\label{FE_code_sections_FE_includes}
The user may add any other include files needed, but should not remove any of the existing ones in the example. The include file \hyperlink{RC_Hot_Link_RC_experim_dot_h}{experim.h} is a special include file for ease of communication between the C code and the \hyperlink{F_MainElements_F_Online_Database_overview}{odb}.

\begin{table}[h]\begin{TabularC}{2}
\hline
VME :  &CAMAC :  \\\cline{1-2}

\begin{DoxyCode}
#include <stdio.h>
#include <stdlib.h>
#include "midas.h"
#include "experim.h"
#include "mvmestd.h"
#include "vmicvme.h"
\end{DoxyCode}
  &
\begin{DoxyCode}
#include <stdio.h>
#include <stdlib.h>
#include "midas.h"
#include "mcstd.h"
#include "experim.h"
\end{DoxyCode}
 \\\cline{1-2}
\end{TabularC}
\centering
\caption{Examples of include files }
\end{table}


\par


\par
 \hypertarget{FE_code_sections_FE_global}{}\subsubsection{Global declarations}\label{FE_code_sections_FE_global}
The declarations are system wide. Some may be changed to suit the user, but none should not be removed.


\begin{DoxyItemize}
\item \hyperlink{frontend_8c_ac1f0c6df66e35778b61c611107501ec4}{frontend\_\-name}   This value can be modified to reflect the purpose of the code.  
\item \hyperlink{frontend_8c_a0215c0a842a0e97fe65c7ef5fb7633a5}{frontend\_\-call\_\-loop}   If set to TRUE, the function \hyperlink{mfe_8c_ad902740ed5577f2f940454359ec1df1c}{frontend\_\-loop()} runs after every equipment loop. If FALSE, \hyperlink{mfe_8c_ad902740ed5577f2f940454359ec1df1c}{frontend\_\-loop()} does not run. The user can add suitable code to this routine if desired (e.g. to check for a condition.  
\item \hyperlink{frontend_8c_ab9cdcefda91459091b0ed33011d0d18c}{display\_\-period}   The time interval (defined in milliseconds) between the refresh of a frontend status display. The value of zero disables the display. \par
 NOTE: If the frontend is started in the background with the display enabled, the stdout should be redirected to the null device to prevent the process from hanging.  
\item \hyperlink{frontend_8c_a13adb6e6b95ca2a62bbfe2453d71a1cd}{max\_\-event\_\-size}   specifies the maximum size (in bytes) of the expected event.  
\item \hyperlink{frontend_8c_a4411d7db6f901c968b946ed659d202f6}{event\_\-buffer\_\-size}   specifies the maximum size (in bytes) of the buffer to be allocated by the system.  
\end{DoxyItemize}


\begin{DoxyCode}
    // The frontend name (client name) as seen by other MIDAS clients
    char *frontend_name = "Sample Frontend";

    // The frontend file name, don't change it
    char *frontend_file_name = __FILE__;

    // frontend_loop is called periodically if this variable is TRUE
    BOOL frontend_call_loop = FALSE;

    //a frontend status page is displayed with this frequency in ms
    INT display_period = 3000;

    //maximum event size produced by this frontend
    INT max_event_size = 200000;

    // maximum event size for fragmented events (EQ_FRAGMENTED) 
    INT max_event_size_frag = 5 * 1024 * 1024;

    //buffer size to hold events
    INT event_buffer_size = 10*10000;
\end{DoxyCode}
 \par


\par
 \hypertarget{FE_code_sections_FE_global_user}{}\subsubsection{Global User declarations}\label{FE_code_sections_FE_global_user}
After the global declarations, the user may add his or her own declarations. The example defines various hardware \hyperlink{structparameters}{parameters}. \begin{table}[h]\begin{TabularC}{2}
\hline
VME :  &CAMAC :  \\\cline{1-2}

\begin{DoxyCode}
/* Hardware */
/* Interrupt vector */
int trig_level =  0;
#define TRIG_LEVEL  (int) 1
#define INT_LEVEL   (int) 3
#define INT_VECTOR  (int) 0x16
extern INT_INFO int_info;
int myinfo = VME_INTERRUPT_SIGEVENT;

MVME_INTERFACE *myvme;
int  inRun = 0;
DWORD VADC0_BASE = 0x100000; // VME base address
DWORD VLAM_BASE  = 0x800000; // VME base address
\end{DoxyCode}
  &
\begin{DoxyCode}
    // Global user section
    // number of channels
    #define N_ADC  8  
    #define N_TDC  8 
    #define N_SCLR 8

    CAMAC crate and slots
    #define CRATE      0
    #define SLOT_C212 23
    #define SLOT_ADC   1
    #define SLOT_TDC   2
    #define SLOT_SCLR  3
\end{DoxyCode}
 \\\cline{1-2}
\end{TabularC}
\centering
\caption{Examples of global declarations }
\end{table}
\par


\par
 \hypertarget{FE_code_sections_FE_system_prototypes}{}\subsubsection{System prototype functions}\label{FE_code_sections_FE_system_prototypes}
These prototypes declare the pre-\/defined system functions which should be present. 
\begin{DoxyCode}
INT frontend_init();
INT frontend_exit();
INT begin_of_run(INT run_number, char *error);
INT end_of_run(INT run_number, char *error);
INT pause_run(INT run_number, char *error);
INT resume_run(INT run_number, char *error);
INT frontend_loop();
\end{DoxyCode}
 \par


\par
 \hypertarget{FE_code_sections_FE_user_prototypes}{}\subsubsection{User prototype functions}\label{FE_code_sections_FE_user_prototypes}
Following this group is a second group of prototypes, which define the \hyperlink{FrontendOperation_FE_equipment_readout_function}{user functions} that run when the defined equipments are triggered. In this example, two equipments will be defined, so there are two prototypes. The user functions will be described in detail in the following sections. 
\begin{DoxyCode}
INT read_trigger_event(char *pevent, INT off);
INT read_scaler_event(char *pevent, INT off);
\end{DoxyCode}


And following this is the prototype 
\begin{DoxyCode}
void register_cnaf_callback(int debug);
\end{DoxyCode}
 which is a routine provided in \hyperlink{cnaf__callback_8c}{cnaf\_\-callback.c}

\par
  \par


\label{index_end}
\hypertarget{index_end}{}
 \subsubsection{Sequence of operations}\label{FE_sequence}
\par
  \par


\label{FE_sequence_idx_Frontend_sequence-of-operations}
\hypertarget{FE_sequence_idx_Frontend_sequence-of-operations}{}
 The following table shows the sequence of operations of the frontend. These system routines are located in the \hyperlink{frontend_8c}{frontend.c} code but are called by \hyperlink{mfe_8c}{mfe.c} at the appropriate time. These routines must be present in the \hyperlink{frontend_8c}{frontend.c} code, but the contents are coded by the user.

\begin{table}[h]\begin{TabularC}{4}
\hline
Associated Transition\par
  &System function \par
  &Action\par
  &\par
   \\\cline{1-4}
\par
  &\hyperlink{mfe_8c_a802849119d469feb2d1deee1be9593ac}{frontend\_\-init()}\par
  &Runs once after system initialization, before equipment registration. &\hyperlink{FE_sequence_FE_frontend_init}{Details}\par
   \\\cline{1-4}
TR\_\-START\par
  &\hyperlink{mfe_8c_ad8bfe703c49342b9f0275aba77dc7758}{begin\_\-of\_\-run()}\par
  &Runs after systerm statistics reset, before any other Equipments at each Beginning of Run request. &\hyperlink{FE_sequence_FE_begin_of_run}{Details}\par
   \\\cline{1-4}
TR\_\-PAUSE &\hyperlink{mfe_8c_a164db20cf6c8c81e8c8ca50a590de436}{pause\_\-run()} &Runs before any other Equipments at each Run Pause request. &\multirow{2}{\linewidth}{\hyperlink{FE_sequence_FE_pause_resume_run}{Details} \par
   }\\\cline{2-4}
TR\_\-RESUME &\hyperlink{mfe_8c_a6cada7e3f07b9fc2b9886263223661d4}{resume\_\-run()} &Runs before any other Equipments at each Run Resume request.

\\\cline{1-3}
TR\_\-STOP &\hyperlink{mfe_8c_ae6d798649008b7523c77222bae2d4187}{end\_\-of\_\-run()} &Runs before any other Equipments at each End of Run request. &\hyperlink{FE_sequence_FE_end_of_run}{Details}\par
   \\\cline{1-4}
\par
  &\hyperlink{mfe_8c_a3b682405038cc4f6af505d7ca6367a4f}{frontend\_\-exit()}\par
  &Runs once before Slow Control Equipment exit. &\par
   \\\cline{1-4}
\end{TabularC}
\centering
\caption{Table showing sequence of operations }
\end{table}


Each equipment has the option to force itself to run at individual transition times (see \hyperlink{FrontendOperation_FE_event_trigger}{Frontend event triggers}), so that its equipment function will be called on a certain \hyperlink{RC_Run_States_and_Transitions}{transition} (or combination of transitions).

However, the {\bfseries system transition functions}
\begin{DoxyItemize}
\item \hyperlink{mfe_8c_ad8bfe703c49342b9f0275aba77dc7758}{begin\_\-of\_\-run()},
\item \hyperlink{mfe_8c_ae6d798649008b7523c77222bae2d4187}{end\_\-of\_\-run()},
\item \hyperlink{mfe_8c_a164db20cf6c8c81e8c8ca50a590de436}{pause\_\-run()} and
\item \hyperlink{mfe_8c_a6cada7e3f07b9fc2b9886263223661d4}{resume\_\-run()} \par
all run {\bfseries prior} to the equipment functions. This gives the system the chance to take basic action on the transition request (e.g. enable/disable interrupt) before the equipment runs.
\end{DoxyItemize}\hypertarget{FE_sequence_FE_frontend_status}{}\subsubsection{Reporting Equipment status}\label{FE_sequence_FE_frontend_status}
If running with run control utility \hyperlink{RC_mhttpd_utility}{mhttpd}, a frontend can send an update to the main status page, to report on its progress, using the function set\_\-equipment\_\-status. This is very useful when hardware can take a long time to respond. For example, a frontend might add calls in the \hyperlink{FE_sequence_FE_frontend_init}{frontend\_\-init()} routine e.g. 
\begin{DoxyCode}
INT frontend_init()
{
   set_equipment_status(equipment[idx].name, "Initializing...", "yellow");
   ......  // Initialize hardware 
   ......
   set_equipment_status(equipment[idx].name, "OK", "green");
}
\end{DoxyCode}


The status messages appear next to the equipment name on the \hyperlink{RC_mhttpd_status_page_features_idx_mhttpd_page_status_equipment}{main status page}.

\par
 \par
 \hypertarget{FE_sequence_FE_frontend_init}{}\subsubsection{frontend\_\-init()}\label{FE_sequence_FE_frontend_init}
This function runs once only at the application startup. Allows hardware checking, loading/setting of global variables, hot-\/link settings to the ODB etc...

\begin{table}[h]\begin{TabularC}{2}
\hline
VME :  &CAMAC :  \\\cline{1-2}

\begin{DoxyCode}
INT frontend_init()
{
 ....
 // Open VME interface
  status = mvme_open(&myvme, 0);

  // Set am to A24 non-privileged Data
  mvme_set_am(myvme, MVME_AM_A24_ND);

  // Set dmode to D32
  mvme_set_dmode(myvme, MVME_DMODE_D32)
  return SUCCESS;
}
\end{DoxyCode}
  &
\begin{DoxyCode}
INT frontend_init()
{
   cam_init();              // Init CAMAC access
   cam_crate_clear(CRATE);  // Clear Crate
   cam_crate_zinit(CRATE);  // Z crate
   cam_inhibit_set(CRATE);  // Set I crate 
   return SUCCESS;
}
\end{DoxyCode}
 \\\cline{1-2}
\end{TabularC}
\centering
\caption{Examples of frontend\_\-init routines }
\end{table}
\par


\par
 \hypertarget{FE_sequence_FE_begin_of_run}{}\subsubsection{begin\_\-of\_\-run}\label{FE_sequence_FE_begin_of_run}
This function is called for every run start transition. Allows the updating of user \hyperlink{structparameters}{parameters}, and the loading/setup/clearing of hardware. At the exit of this function the acquisition should be armed and ready to test the interrupt (if used).

In case of a CAMAC frontend, the LAM has to be declared to the Crate Controller. The function {\bfseries cam\_\-lam\_\-enable(CRATE, SLOT\_\-IO)} is then necessary in order to enable the proper LAM source station. The LAM source station has to also be enabled (F26). \par
\par
 The arguments
\begin{DoxyItemize}
\item {\bfseries run\_\-number} provides the current run number being started.
\item {\bfseries error} can be used for returning a message to the system. This message string will be logged into the {\bfseries midas.log} file. \par

\end{DoxyItemize}

\begin{table}[h]\begin{TabularC}{2}
\hline
VME :  &CAMAC :  \\\cline{1-2}

\begin{DoxyCode}
INT begin_of_run (INT runnumber, char * error)
{
  ......

  // Set am to A24 non-privileged Data
  mvme_set_am(myvme, MVME_AM_A24_ND);
  // Set dmode to D32
  mvme_set_dmode(myvme, MVME_DMODE_D32);

 //-------- ADCs -------------------
  v792_Setup(myvme, VADC0_BASE, 2);
  v792_ThresholdWrite(myvme, VADC0_BASE,
       (WORD *)&(ts.v792.threshold1));
  v792_DataClear(myvme, VADC0_BASE);
  csr = v792_CSR1Read(myvme, VADC0_BASE);
  printf("Data Ready ADC0: 0x%x\n", csr);
  ........
  // Disable interrupt
  mvme_write_value(myvme, VLAM_BASE+4, 0x0);
  // Reset Latch
  mvme_write_value(myvme, VLAM_BASE, 0x1);
  // Clear pending interrupts
  mvme_write_value(myvme, VLAM_BASE+8, 0x0);
  // Enable interrupt
  inRun = 1;
  mvme_write_value(myvme, VLAM_BASE+4, inRun);
  return SUCCESS;
}
\end{DoxyCode}
  &
\begin{DoxyCode}
INT begin_of_run (INT runnumber, char * error)
{
  ......
  // clear units
  camc(CRATE, SLOT_C212, 0, 9);
  camc(CRATE, SLOT_2249A, 0, 9);
  camc(CRATE, SLOT_SC2, 0, 9);
  camc(CRATE, SLOT_SC3, 0, 9);

  // Enable LAM generation
  camc(CRATE, SLOT_C212, 0, 26);  

  cam_inhibit_clear(CRATE); // Remove I
  // Declare Station to  CC as LAM source
  cam_lam_enable(CRATE, SLOT_C212);


  // set and clear OR1320 pattern bits
  camo(CRATE, SLOT_OR1320, 0, 18, 0x0330);
  // Open run gate, reset latch
  camo(CRATE, SLOT_OR1320, 0, 21, 0x0663);
  return SUCCESS;
}
\end{DoxyCode}


\\\cline{1-2}
\end{TabularC}
\centering
\caption{Examples of begin\_\-of\_\-run routines }
\end{table}
\par


\par
 \hypertarget{FE_sequence_FE_pause_resume_run}{}\subsubsection{pause\_\-run() or resume\_\-run()}\label{FE_sequence_FE_pause_resume_run}
These two functions are called respectively upon \char`\"{}Pause\char`\"{} and \char`\"{}Resume\char`\"{} command. Any code relevant to the upcoming run state can be included.

\begin{table}[h]\begin{TabularC}{2}
\hline
VME :  &CAMAC :  \\\cline{1-2}

\begin{DoxyCode}
INT pause_run (INT run_number, char * error)
{
 // Disable interrupt
  inRun = 0;
  mvme_write_value(myvme, VLAM_BASE+4, inRun);
   return SUCCESS;
}

INT resume_run (INT run_number, char * error)
{
 inRun = 1;
 mvme_write_value(myvme, VLAM_BASE+4, inRun);
   return SUCCESS;
}
\end{DoxyCode}
  &
\begin{DoxyCode}
INT pause_run (INT run_number, char * error)
{
   cam_inhibit_set(CRATE)
   return SUCCESS;
}
INT resume_run (INT run_number, char * error)
{
   cam_inhibit_clear(CRATE)
   return SUCCESS;
}  
\end{DoxyCode}


\\\cline{1-2}
\end{TabularC}
\centering
\caption{Examples of pause\_\-run and resume\_\-run routines }
\end{table}


The arguments
\begin{DoxyItemize}
\item {\bfseries run\_\-number} provides the current run number being paused/resumed.
\item {\bfseries error} can be used for returning a message to the system. This message string will be logged into the midas.log file.
\end{DoxyItemize}

\par


\par
 \hypertarget{FE_sequence_FE_end_of_run}{}\subsubsection{end\_\-of\_\-run()}\label{FE_sequence_FE_end_of_run}
For every \char`\"{}stop run\char`\"{} transition this function is called and provides the opportunity to disable the hardware. \begin{table}[h]\begin{TabularC}{2}
\hline
VME :  &CAMAC :  \\\cline{1-2}

\begin{DoxyCode}
INT end_of_run(INT run_number, char *error)
{
  // Stop DAQ for seting up the parameters
  vf48_AcqStop(myvme, VF48_BASE);

  done = 0;
  stop_req = 0;
  inRun = 0;
  // Disable interrupt
  mvme_write_value(myvme, VLAM_BASE+4, inRun);
  trig_level = 0;
  // Close run gate
  vmeio_AsyncWrite(myvme, VMEIO_BASE, 0x0);
  return SUCCESS;
}
\end{DoxyCode}
 &
\begin{DoxyCode}
INT end_of_run( INT run_number, char* error)
{
   // set and clear OR1320 pattern bits or close run gate.
   camo(CRATE, SLOT_OR1320, 0, 18, 0x0CC3);
   camo(CRATE, SLOT_OR1320, 0, 21, 0x0990);
   // Enable LAM generation
   camc(CRATE, SLOT_C212, 0, 26);  
   // disable LAM in crate controller
   cam_lam_disable(CRATE, SLOT_C212);
   // set crate inhibit 
   cam_inhibit_set(CRATE);          
   return SUCCESS;
}
\end{DoxyCode}
 \\\cline{1-2}
\end{TabularC}
\centering
\caption{Examples of end\_\-of\_\-run routines }
\end{table}
The arguments
\begin{DoxyItemize}
\item {\bfseries run\_\-number} provides the current run number being ended.
\item {\bfseries error} can be used for returning a message to the system. This message string will be logged into the midas.log file. \par

\end{DoxyItemize}

\par
 \hypertarget{FE_sequence_FE_frontend_exit}{}\subsubsection{frontend\_\-exit()}\label{FE_sequence_FE_frontend_exit}
This function runs when the frontend is requested to terminate. Can be used for local statistic collection etc.

\par
  \par


\label{index_end}
\hypertarget{index_end}{}
 \subsubsection{Frontend Routines associated with Equipments}\label{FE_eq_event_routines}
\label{FE_eq_event_routines_idx_event_readout_routines}
\hypertarget{FE_eq_event_routines_idx_event_readout_routines}{}
 \par
  \par
 \par
 \label{FE_eq_event_routines_idx_event_polled}
\hypertarget{FE_eq_event_routines_idx_event_polled}{}
 \hypertarget{FE_eq_event_routines_FE_poll_event}{}\subsubsection{Polled event}\label{FE_eq_event_routines_FE_poll_event}
If the \hyperlink{FE_table_FE_tbl_EqType}{Equipment Type} is \hyperlink{FE_table_FE_tbl_EqPolled}{EQ\_\-POLLED}, the {\bfseries \hyperlink{mfe_8c_a98cc3257284af91fa0e8da10ddf227c8}{poll\_\-event()}} routine will be called as often as possible over the corresponding \hyperlink{FE_table_FE_tbl_EqPolled}{poll time} (e.g. 500ms) given by each polling equipment.

In this case, the \hyperlink{FE_eqdec_FE_Example_equipment_structure}{Equipment declaration} would have this form:


\begin{DoxyCode}
    EQUIPMENT equipment[] = {

      { "Trigger",            // equipment name
        {
          ...
          EQ_POLLED,          // equipment type
          ...
          500,                // poll for 500ms 
          ...
          "", "", "",},
       read_trigger_event,    // readout routine 
       ...
\end{DoxyCode}


The user must provide suitable code in the routine {\bfseries \hyperlink{mfe_8c_a98cc3257284af91fa0e8da10ddf227c8}{poll\_\-event()}}.

The code below shows a typical LAM polling loop.\par
 In the case of CAMAC, the {\bfseries source} corresponds to a bitwise LAM station able to generate LAM for that particular equipment. If the LAM is ORed for several stations and is independent of the equipment, the LAM test can be simplified (see example below) \begin{table}[h]\begin{TabularC}{2}
\hline
VME :  &CAMAC :  \\\cline{1-2}

\begin{DoxyCode}
INT poll_event(INT source, INT count, BOOL test)
{
/* Polling routine for events. 
   Returns TRUE if event is available. 
   If test equals TRUE, don't return. 
   The test flag is used to time the polling.
*/

  int i;
  int lam = 0;

  for (i = 0; i < count; i++, lam++) {
    lam = vmeio_CsrRead(myvme, VMEIO_BASE);
    if (lam)
      if (!test)
        return lam;
  }

  return 0;
}
\end{DoxyCode}
 &


\begin{DoxyCode}
INT poll_event(INT source, INT count, BOOL test)
{
/* Polling routine for events. 
   Returns TRUE if event is available. 
   If test equals TRUE, don't return. 
   The test flag is used to time the polling.
 */
   int   i;
   DWORD lam;
 
   for (i=0 ; i<count ; i++)
   {
     cam_lam_read(LAM_SOURCE_CRATE(source), &lam);
     // Either ... any of the equipment LAM
     if (lam & LAM_SOURCE_STATION(source))
     //  
     // Or ... any LAM (independent of the equipment)
     if (lam)                             

       if (!test)
         return lam;
   }
   return 0;
} 
\end{DoxyCode}
 \\\cline{1-2}
\end{TabularC}
\centering
\caption{Examples of poll\_\-event routines }
\end{table}


An \hyperlink{FE_eq_event_routines_FE_poll_or_interrupt_readout_routine}{event readout routine} must also be provided by the user (see below).

\par


\par
 \label{FE_eq_event_routines_idx_event_interrupt}
\hypertarget{FE_eq_event_routines_idx_event_interrupt}{}
 \hypertarget{FE_eq_event_routines_FE_interrupt_event}{}\subsubsection{Interrupt event}\label{FE_eq_event_routines_FE_interrupt_event}
If the Equipment type is \hyperlink{FE_table_FE_tbl_EqType}{EQ\_\-INTERRUPT}, an interrupt configuration routine called \hyperlink{mfe_8c_a681a5d1fe2e8a4735bcf03824ffb3e81}{interrupt\_\-configure()} must be provided in the \hyperlink{frontend_8c}{frontend.c} by the user.

The interrupt configuration routine has the following declaration: \begin{table}[h]\begin{TabularC}{2}
\hline
VME :  &CAMAC :  \\\cline{1-2}

\begin{DoxyCode}
/*-- Interrupt configuration --------------------------*/
INT interrupt_configure(INT cmd, INT source, PTYPE adr)
{
  int vec = 0;
  switch (cmd) 
  {
    case CMD_INTERRUPT_ENABLE:
      if (inRun) mvme_write_value(myvme, VLAM_BASE+4, 0x1);
      break;

    case CMD_INTERRUPT_DISABLE:
      if (inRun) mvme_write_value(myvme, VLAM_BASE+4, 0x0);
      break;

    case CMD_INTERRUPT_ATTACH:
      mvme_set_dmode(myvme, MVME_DMODE_D32);
      mvme_interrupt_attach(myvme, INT_LEVEL, INT_VECTOR, 
                (void *)adr, &myinfo);
      mvme_write_value(myvme, VLAM_BASE+0x10, INT_VECTOR);
      vec = mvme_read_value(myvme, VLAM_BASE+0x10);
      printf("Interrupt Attached to 0x%x for vector:0x%x\n",
                     adr, vec&0xFF);
      break;

    case CMD_INTERRUPT_DETACH:
      printf("Interrupt Detach\n");
      break;
   }
   return SUCCESS;
}
\end{DoxyCode}
 &
\begin{DoxyCode}
INT interrupt_configure(INT cmd, INT source [], PTYPE adr)
{
   switch(cmd)
     {
      case CMD_INTERRUPT_ENABLE:
        cam_interrupt_enable();
        break;

      case CMD_INTERRUPT_DISABLE:
        cam_interrupt_disable();
        break;

      case CMD_INTERRUPT_ATTACH:
        cam_interrupt_attach((void (*)())adr);
        break;

      case CMD_INTERRUPT_DETACH:
        cam_interrupt_detach();
        break;

      }
  return CM_SUCCESS; 
}
\end{DoxyCode}
 \\\cline{1-2}
\end{TabularC}
\centering
\caption{Examples of interrupt\_\-configure routines }
\end{table}


Under the four commands listed above, the user must implement the hardware operation needed to perform the requested action. In the Midas {\bfseries  drivers } directory examples can be found of such an interrupt code for CAMAC. See source code such as hyt1331.c,ces8210.c .

An event readout routine must also be provided by the user in \hyperlink{frontend_8c}{frontend.c} . In the case of POLLED or INTERRUPT events, the event readout routine is called an \hyperlink{FE_eq_event_routines_FE_poll_or_interrupt_readout_routine}{interrupt readout routine}. An example is shown below.

\par


\par
\hypertarget{FE_eq_event_routines_FE_readout_routine}{}\subsubsection{Event Readout routines}\label{FE_eq_event_routines_FE_readout_routine}
An event readout routine (called when an event occurs) is usually of the form 
\begin{DoxyCode}
INT function_name ( char *pevent ... )
{
   INT event_size;

   ........  // read data from hardware
   ........  // pack into banks depending on format
   ........
   return (event_size);
}
\end{DoxyCode}
 where the first argument of the readout function (pevent)~ provides the pointer to the newly constructed event, and points to the first valid location for storing the data. \par
 {\bfseries NOTE:} 
\begin{DoxyItemize}
\item The return value is the event size, and must be the number of bytes collected in this function.  
\item The {\bfseries event serial number} will be incremented by one for every call to the readout routine, as long as the returned size is non-\/zero.  
\item If the {\bfseries returned value is set to zero}, the event will be dismissed and the serial number to that event will be decremented by one.  
\end{DoxyItemize}\par


\par
 \hypertarget{FE_eq_event_routines_FE_poll_or_interrupt_readout_routine}{}\paragraph{Polled or Interrupt readout routine}\label{FE_eq_event_routines_FE_poll_or_interrupt_readout_routine}
In the case of an Interrupt or Polled event, the content of the memory location pointed to by {\bfseries pevent} prior to its use in the readout function, contains the interrupt source bitwise register. This feature can be exploited in order to identify which hardware module has triggered the readout when multiple interrupts have been assigned to the same readout function.

The examples below show a VME interrupt source and a CAMAC multiple LAM interrupt source for a given equipment. Depending whether USE\_\-INT is defined, the Equipment will either use a \hyperlink{FE_eq_event_routines_FE_poll_event}{Polled} or an \hyperlink{FE_eq_event_routines_FE_interrupt_event}{Interrupt} mechanism. \par
 The Equipment declaration is of the form: \begin{table}[h]\begin{TabularC}{2}
\hline
VME :  &CAMAC :  \\\cline{1-2}

\begin{DoxyCode}
EQUIPMENT equipment[] = {

   {"Trigger",  /* equipment name */
     ...
#ifdef USE_INT
     EQ_INTERRUPT, /* equipment type */
#else
     EQ_POLLED,    /* equipment type */
#endif
 /* interrupt source: crate 0, all stations */
     LAM_SOURCE(0, 0x0),
     ....
     "", "", "",},
    read_trigger_event, /* readout routine */
    NULL, NULL,
    trigger_bank_list,
    }
\end{DoxyCode}
 &
\begin{DoxyCode}
    EQUIPMENT equipment[] = {
      { "Trigger",  // equipment name
         {    
            ...
// the same readout code will be used for
// either Interrupt or Polled equipment
#ifdef USE_INT
            EQ_INTERRUPT,
#else                     
            EQ_POLLED,
#endif
            LAM_SOURCE(JW_C,  LAM_STATION(GE_N)
                   | LAM_STATION(JW_N)), // interrupt source 
            ...
            "", "", "",},
       read_trigger_event,   // event readout routine 
       ...
\end{DoxyCode}
 \\\cline{1-2}
\end{TabularC}
\centering
\caption{Examples of POLLED or INTERRUPT Equipment list }
\end{table}


Note that the LAM\_\-SOURCE macro is used in both cases. It simply codes the \hyperlink{structparameters}{parameters} into a bitwise register.

The readout routine would contains code such as \begin{table}[h]\begin{TabularC}{2}
\hline
VME :  &CAMAC :  \\\cline{1-2}

\begin{DoxyCode}
INT read_trigger_event(char *pevent, INT off)
{
#if defined VADC0_CODE
  DWORD  *pdata;
#endif

#if defined VADC0_CODE
  /* read ADC0 data */
  v792_EvtCntRead(myvme, VADC0_BASE, &evtcnt);
  ........
  /* Read Event */
  v792_EventRead(myvme, VADC0_BASE, pdata, &nentry);
  ........
  v792_DataClear(myvme, VADC0_BASE);
#endif

  ........
  return (size);
}
\end{DoxyCode}
  &
\begin{DoxyCode}
  INT read_trigger_event(char *pevent, INT off)
  {
    DWORD lam;

    lam = *((DWORD *)pevent);

    // check LAM versus MCS station
    // The clear is performed at the end of the readout function
    if (lam & LAM_STATION(JW_N))
    {
       // read MCS event 
       size = read_mcs_event(pevent);
       ...
    }
    else if (lam & LAM_STATION(GE_N))
    {
       ...
       // read GE event
       size = read_ge_event(pevent);
       ...
     }
     clear_LAM(); // clear all LAMs
  return size;
} 
\end{DoxyCode}
  \\\cline{1-2}
\end{TabularC}
\centering
\caption{Examples of readout routines }
\end{table}
{\bfseries NOTE:} \par
 In the CAMAC example above, the Midas Event Header contains the same Event ID as the Trigger mask for both LAM. The examples \hyperlink{fevmemodules_8c}{fevmemodules.c} (VME) and \hyperlink{frontend_8c}{frontend.c} (CAMAC) contain a complete example of \hyperlink{fevmemodules_8c_a9c54bafa1af403e5e4737f9d8d5aba07}{read\_\-trigger\_\-event()}.

\par


\par
 \hypertarget{FE_eq_event_routines_FE_other_event}{}\paragraph{General readout function}\label{FE_eq_event_routines_FE_other_event}
If the \hyperlink{FE_table_FE_tbl_EqType}{Equipment type} is {\bfseries not} EQ\_\-INTERRUPT or EQ\_\-POLLED, the readout routine is the only event routine that the user needs to provide in \hyperlink{frontend_8c}{frontend.c} .

In this case (e.g. a {\bfseries periodic} event) the \hyperlink{FE_eqdec_FE_Example_equipment_structure}{Equipment declaration} may have this form: 
\begin{DoxyCode}
    EQUIPMENT equipment[] = {
      { "Scaler",           // equipment name
         {    
            ...
            EQ_PERIODIC     // equipment type
            0,              // interrupt source (ignored) 
            ...
            10000,          // period (read every 10s)
            ...
            "", "", "",},
       read_scaler_event,   // readout routine 
       ...
\end{DoxyCode}


An example of a scaler readout routine \hyperlink{fevmemodules_8c_af3ad062393c1437922bae26841d8927c}{read\_\-scaler\_\-event()} where the data is read out into \hyperlink{FE_bank_construction}{data banks} is shown below. 
\begin{DoxyCode}
INT read_scaler_event(char *pevent, INT off)
{
   DWORD *pdata, a;

   /* init bank structure */
   bk_init(pevent);

   /* create SCLR bank */
   bk_create(pevent, "SCLR", TID_DWORD, &pdata);

   /* read scaler bank (CAMAC) */
   for (a = 0; a < N_SCLR; a++)
      cam24i(CRATE, SLOT_SCLR, a, 0, pdata++);
    
   /* close SCLR bank */
   bk_close(pevent, pdata);

   /* return event size in bytes */
   return bk_size(pevent);
}
\end{DoxyCode}


\par
 

 \par


\label{FE_eq_event_routines_idx_event_fragmented}
\hypertarget{FE_eq_event_routines_idx_event_fragmented}{}
 \hypertarget{FE_eq_event_routines_FE_fragmented_event}{}\paragraph{Fragmented Event}\label{FE_eq_event_routines_FE_fragmented_event}
A {\bfseries fragmented} event enables very large events (e.g. beyond the Midas configuration limit) to be handled by the system. This is not to be confused with the use of the Event Builder, where \char`\"{}event fragments\char`\"{} are combined by an \hyperlink{FE_Event_Builder_FE_mevb_utility}{event-\/builder}.

The event is sent out by the frontend in smaller fragments, and reassembled by the Midas system into one event. This option is useful in experiments where the event rate is not an issue, but the size of the data needs to be extremely large. The Equipment flag \hyperlink{FE_table_FE_tbl_EqFragmented}{EQ\_\-FRAGMENTED} indicates that the event is fragmented. The {\bfseries fragment size} is determined by \char`\"{}max\_\-event\_\-size\char`\"{} in the frontend code \hyperlink{FE_eq_event_routines_FE_frag_max_event_size}{(see below)}.

The example used \hyperlink{FE_eq_event_routines_FE_tdmusr_equipment}{below} is taken from the TRIUMF TD-\/MUSR experiment, where a VME PowerPC (PPC) running VxWorks is used as the frontend cpu, and acts as a Histogramming Memory (HM). The backend computer is a Linux PC.

Depending on the time range (i.e. number of bins selected) the histograms may be very large. The memory of the PPC is limited, and most of the free memory is needed for the HM, so the event buffer size is set to be relatively small. Therefore the histograms can only be sent out in fragments.

\label{FE_eq_event_routines_idx_event_manual-trigger}
\hypertarget{FE_eq_event_routines_idx_event_manual-trigger}{}
 \hypertarget{FE_eq_event_routines_FE_manual_trigger}{}\paragraph{Manual Trigger}\label{FE_eq_event_routines_FE_manual_trigger}
Another feature illustrated in this example \hyperlink{FE_eq_event_routines_FE_tdmusr_equipment}{below} is the {\bfseries  Manual Trigger}, indicated by the Equipment flag \hyperlink{FE_table_FE_tbl_EqManTrig}{EQ\_\-MANUAL\_\-TRIG}. This flag causes an extra button to be present on the mhttpd web interface to enable the user to trigger the event. The following image is of the main status page of the MUSR experiment, where two manual trigger buttons are shown, labelled
\begin{DoxyItemize}
\item \char`\"{}Trigger Histo event\char`\"{} and
\item \char`\"{}Trigger Camp event\char`\"{}.
\end{DoxyItemize}

These have been generated for the Histo and Camp Equipments which were both set up with the EQ\_\-MANUAL\_\-TRIG flag. \par
 \begin{center} mhttpd status page showing Manual Trigger Buttons  \end{center}  \par


It is also possible for a \hyperlink{FE_eq_event_routines_FE_backend_Manual_Trigger}{client to trigger a manual trigger event}. The MUSR custom data archiver (a backend Midas client) controls when an event is sent, by means of a \hyperlink{FE_eq_event_routines_FE_backend_Manual_Trigger}{routine} that requests an event by triggering the event sending mechanism with a RPC call.\hypertarget{FE_eq_event_routines_FE_manual_trig_determine}{}\subparagraph{How to determine if trigger was a manual trigger}\label{FE_eq_event_routines_FE_manual_trig_determine}
In some cases, the same readout code may be used for two types of event: a manual trigger and (say) a poll event. It is possible to determine whether the readout of an event was triggered by a manual trigger or a regular trigger by adding the following call to the readout routine: 
\begin{DoxyCode}
  flag = DATA_SIZE(pevent);
\end{DoxyCode}


\par
 If the result is
\begin{DoxyItemize}
\item flag = 0 normal call
\item flag = 1 manual trigger
\end{DoxyItemize}\hypertarget{FE_eq_event_routines_FE_tdmusr_equipment}{}\paragraph{Equipment declaration for manually-\/triggered and fragmented event}\label{FE_eq_event_routines_FE_tdmusr_equipment}
The Equipment declaration for the manually triggered fragmented histogram event (named Histo) is as follows:


\begin{DoxyCode}
 { "Histo",             /* equipment name */
    2, 0,                 /* event ID, trigger mask */
    "SYSTEM",             /* event buffer */
    EQ_MANUAL_TRIG |     /* equipment type */
    EQ_FRAGMENTED,        /*    manual trigger, fragmented (no longer periodic)
 */
    0,                    /* interrupt source */
    "MIDAS",               /* format */
    TRUE,                 /* enabled */
    RO_RUNNING | RO_EOR |
    RO_PAUSE | RO_RESUME, /* read when running and on end run,pause,resume tran
sition */
    0,                    /* not polled */
    0,                    /* stop run after this event limit */
    0,                    /* number of sub event */
    0,                    /* log history */
   "", "", "",
    histo_read,     /* readout routine */
    NULL,NULL,NULL       /* keep null */
  },
\end{DoxyCode}


The Histo event can be manually triggered only {\bfseries when running}, and is also triggered by the transitions {\bfseries STOP, PAUSE} and {\bfseries RESUME}, \par
indicated by the \hyperlink{FE_table_FE_tbl_ReadOn}{Read-\/On Event flags} : \par
 {\bfseries RO\_\-RUNNING $|$ RO\_\-EOR $|$ RO\_\-PAUSE $|$ RO\_\-RESUME}.

\label{FE_eq_event_routines_idx_event_fragmented_size}
\hypertarget{FE_eq_event_routines_idx_event_fragmented_size}{}
 \hypertarget{FE_eq_event_routines_FE_frag_max_event_size}{}\paragraph{Event size adjustments for fragmented event}\label{FE_eq_event_routines_FE_frag_max_event_size}
The buffer sizes in the frontend must be adjusted to suit the available memory for the event buffer (used for sending out the event fragments) and to determine the maximum fragment size.

The standard sizes in \hyperlink{frontend_8c}{frontend.c} are 
\begin{DoxyCode}
    //maximum event size produced by this frontend
    INT max_event_size = 200000; /* must be less than MAX_EVENT_SIZE in midas.h *
      / 

    // maximum event size for fragmented events (ignored unless flag EQ_FRAGMENTE
      D is true) 
    INT max_event_size_frag = 5 * 1024 * 1024;

    //buffer size to hold events
    INT event_buffer_size = 10*10000;
\end{DoxyCode}


The frontend code under VxWorks uses the following sizes to accomodate the fragmented events: 
\begin{DoxyCode}
    INT max_event_size = 10000; /* maximum size of event fragments */

    INT max_event_size_frag = 4300000  ; /* maximum size of event (assembled from
       fragments) */

    INT event_buffer_size = 2*10000; /* buffer size to hold events; must be  >= 2
      *max_event_size  */
\end{DoxyCode}



\begin{DoxyItemize}
\item The value of {\bfseries max\_\-event\_\-size} is set much smaller than the standard size, and determines the size of the event fragments.
\item The maximum size of the final event is given by {\bfseries max\_\-event\_\-size\_\-frag}.
\end{DoxyItemize}\hypertarget{FE_eq_event_routines_FE_frag_readout_code}{}\paragraph{Readout routine for fragmented event}\label{FE_eq_event_routines_FE_frag_readout_code}
The readout routine packs the event into \hyperlink{FE_bank_construction}{Midas data banks}, and is no different to a readout routine for a non-\/fragmented event. Sending the event as fragments and reassembling it is transparent to the user, as it is handled by the system routine \hyperlink{mfe_8c}{mfe.c} .


\begin{DoxyCode}
INT histo_read (char *pevent, INT off)
{
  DWORD *pdata, *pmem;
  INT i;
  char hist_name[10];
  DWORD offset; /* offset in words into HM */

  /* init bank structure */
  bk_init32(pevent);

  for (i=0; i<max_channels; i++)   /* for each histogram */

  {
    sprintf(hist_name, "HI%02d", i);
    offset = HM_word_offset[i]; /* find offset into HM for this histo */

    /* create HIxx bank */

      bk_create(pevent, hist_name , TID_DWORD, &pdata);
      pmem = pmemBase + offset; /* add offset */



      /* send out the number of bins requested */
      memcpy(pdata, pmem, number_of_bins * sizeof(DWORD));
      pdata +=  number_of_bins; /* do not cast no. bins! */
     
      bk_close(pevent, pdata);
    
  } /* end of loop on all channels (histograms) */

  return bk_size(pevent);
}
\end{DoxyCode}


\label{FE_eq_event_routines_idx_event_manual-trigger_client}
\hypertarget{FE_eq_event_routines_idx_event_manual-trigger_client}{}
 \hypertarget{FE_eq_event_routines_FE_backend_Manual_Trigger}{}\paragraph{A Client that Manually Triggers the Equipment}\label{FE_eq_event_routines_FE_backend_Manual_Trigger}
If the frontend equipment declares a {\bfseries Manual Trigger}, in addition to the event being triggered by pressing a button on the web interface, a {\bfseries backend program can be used to trigger the event}. \par
 In the case of the \hyperlink{FE_eq_event_routines_FE_manual_trigger}{example above} where a PPC acts as a Histogramming Memory (HM), a {\bfseries  custom data logger } is used to save the contents of the HM periodically during the run, to guard against data loss in the event of failure, and to allow an analyzer to display the histograms during the run. At the end of run (and on Pause/Continue transitions) the Histo event is sent automatically due to the \hyperlink{FE_eq_event_routines_FE_tdmusr_equipment}{Equipment flags} RO\_\-PAUSE, RO\_\-CONTINUE and RO\_\-EOR. \par
 During the run, when it is time to save the contents of the HM, the custom data logger needs to send a manual trigger in order to request a histogram event. This is done by with the Midas library call rpc\_\-client\_\-call in the function \char`\"{}trigger\_\-histo\_\-event\char`\"{} below. The main program uses the Midas library call bm\_\-request\_\-event to place an event request for the desired Histo event(event ID = 2). The following code illustrates the technique:


\begin{DoxyCode}
/*-------- Custom data logger code fragment  ------------------*/

int main(unsigned int argc,char **argv)
{

   ............
   /* connect to experiment */
   status = cm_connect_experiment(host_name, expt_name, ClientName, 0);

   /* turn on message display, turn on message logging */
    cm_set_msg_print(MT_ALL, MT_ALL, msg_print);

 
   /* set the buffer cache size */
    bm_set_cache_size(hBufEvent, 100000, 0);

   /* TD-MUSR uses fragmented events so needs GET_ALL  */
   bm_request_event(hBufEvent, 2, TRIGGER_ALL, GET_ALL, &request_id, process_even
      t_TD);

   .....................
   .....................
}
\end{DoxyCode}


When it is time to save the data during the run, the funtion below (trigger\_\-histo\_\-event) is called:


\begin{DoxyCode}
/*-------------------------------------------------------------------------------
      ----------------*/
BOOL trigger_histo_event(void)
/*-------------------------------------------------------------------------------
      ----------------*/
{
  HNDLE hconn;
  BOOL event_triggered;

  event_triggered = FALSE;

  ...................

  if (run_state == STATE_RUNNING)
    {
     // Check the frontend client exists
     if( cm_exist(ClientName,TRUE))      
        { 
          status = cm_connect_client (ClientName, &hconn);
          if(status != RPC_SUCCESS)
            cm_msg(MERROR,"trigger_histo_event","Cannot connect to frontend \"%s\
      " (%d)",
                   ClientName,status);
      else      
         {  // successfully connected to frontend client
            rpc_client_call(hconn, RPC_MANUAL_TRIG, 2); // trigger a histo event
            if (status != CM_SUCCESS)
              cm_msg(MERROR,"trigger_histo_event","Error triggering event from fr
      ontend (%d)",status);
            else
              {  // successfully triggered event
                event_triggered=TRUE;
                status =cm_disconnect_client(hconn, FALSE);
                if (status != CM_SUCCESS)
                  cm_msg(MERROR,"trigger_histo_event","Error disconnecting client
       after event trigger(%d)",status)
;
              }
          }
       } // end of cm_exist
      else
        cm_msg(MERROR,"trigger_histo_event","Frontend client %s not running; not 
      triggering an event (%d)",
               ClientName,status);
    } // end of if running
  return(event_triggered);
}
\end{DoxyCode}
 \par
 \par
  \par
 \label{index_end}
\hypertarget{index_end}{}
 \subsubsection{Frontend Event Notification}\label{FE_event_notification}
\par
 

We have already seen how some values in the Equipment/Settings area are \hyperlink{FE_ODB_equipment_tree_FE_equipment_odb_hot_links}{automatically hot-\/linked} for convenience. Most frontends also contain user-\/defined {\bfseries hot-\/links} for event notification. These are often used to set or read back hardware value(s) with {\bfseries immediate} {\bfseries effect}, based on the user changing a setting in the ODB. These are described (with an example) in \hyperlink{RC_Hot_Link}{Event Notification (Hot-\/Link)} .

\par


\par
 \label{FE_event_notification_idx_transition_deferred}
\hypertarget{FE_event_notification_idx_transition_deferred}{}
 \hypertarget{FE_event_notification_FE_Deferred_Transition}{}\subsubsection{Deferred Transition}\label{FE_event_notification_FE_Deferred_Transition}
This option permits the user to {\bfseries postpone any transition issued by any requester until some condition is satisfied.} \par
 For example:
\begin{DoxyItemize}
\item It may not be advisable to pause or stop a run until some hardware has turned off a particular valve.
\item The start of the acquisition system should be postponed until the beam rate has been stable for a given period of time.
\item While active, a particular acquisition system should not be interrupted until the \char`\"{}cycle\char`\"{} is completed.
\end{DoxyItemize}

In these examples, any application having access to the state of the hardware can register to be a \char`\"{}transition Deferred\char`\"{} client. The MIDAS system will then catch any transition request and postpone the trigger of such a transition until the condition is satisfied. \par
 The Deferred\_\-Transition requires 3 steps for setup:


\begin{DoxyItemize}
\item Register for the deferred transition. 
\begin{DoxyCode}
    //-- Frontend Init
    INT frontend_init()
    {
      INT    status, index, size;
      BOOL   found=FALSE;

      // register for deferred transition

      cm_register_deferred_transition(TR_STOP, wait_end_cycle);
      cm_register_deferred_transition(TR_PAUSE, wait_end_cycle);
      ...  
\end{DoxyCode}

\item Provide callback function to serve the deferred transition 
\begin{DoxyCode}
  //-- Deferred transition callback
  BOOL wait_end_cycle(int transition, BOOL first)
  {
    if (first)
    {
      transition_PS_requested = TRUE;
      return FALSE;


    }

    if (end_of_mcs_cycle)

    {
      transition_PS_requested = FALSE;
      end_of_mcs_cycle = FALSE;
      return TRUE;

    else
      return FALSE;
    ...
\end{DoxyCode}

\item Implement the condition code
\end{DoxyItemize}


\begin{DoxyCode}
  ... In this case at the end of the readout function...
    ...

  INT read_mcs_event(char *pevent, INT offset)
  {
    ...

    if (transition_PS_requested)
    {
      // Prevent getting a new MCS event by skipping re_arm_cycle and GE by GE_DI
      SABLE LAM
      cam_lam_disable(JW_C,JW_N);
      cam_lam_disable(GE_C,GE_N);
      cam_lam_clear(JW_C,JW_N);

      cam_lam_clear(GE_C,GE_N);
      camc(GE_C,GE_N,0,GE_DISABLE);
      end_of_mcs_cycle = TRUE;

    re_arm_cycle(); 
   return bk_size(pevent);
\end{DoxyCode}


In the example above,


\begin{DoxyItemize}
\item The frontend code is registered for PAUSE and STOP using {\itshape cm\_\-register\_\-deferred\_\-transition\/}. \par
 The second argument {\itshape wait\_\-end\_\-cycle\/} is the declaration of the callback function.
\end{DoxyItemize}


\begin{DoxyItemize}
\item The callback function {\itshape wait\_\-end\_\-cycle\/} will be called as soon as the transition is requested with the Boolean flag {\itshape first\/} set to TRUE.
\item By setting {\itshape transition\_\-PS\_\-requested\/} to TRUE , the user will be provided with the acknowledgment of the transition request.
\item By returning FALSE from the callback, the transition is prevented from occurring.
\end{DoxyItemize}


\begin{DoxyItemize}
\item As soon as the user condition is satisfied (end\_\-of\_\-mcs\_\-cycle = TRUE), the return code in the callback will be set to TRUE and the requested transition will be issued.
\end{DoxyItemize}

The Deferred transition appears in the ODB under {\bfseries /runinfo/Requested transition} and will contain the transition code (see \hyperlink{RC_Run_States_and_Transitions_RC_state_transition}{MIDAS State and Transition Codes} ).

When the system is in deferred state, an ODBedit override command can be issued to {\bfseries force} the transition to happen. eg: 
\begin{DoxyCode}
C:\online>odbedit
 [local]/>stop now 
 [local]/>start now
\end{DoxyCode}


This overide will call the transition function regardless of the state of the hardware involved.

\par
 

\par


\label{index_end}
\hypertarget{index_end}{}
 \subsubsection{Bank construction in an Event readout routine}\label{FE_bank_construction}
\label{FE_bank_construction_idx_bank_construction}
\hypertarget{FE_bank_construction_idx_bank_construction}{}
 \par
 

\par


A readout event will often need to construct banks in which the data is to be sent out. The \hyperlink{FE_table_FE_tbl_Format}{bank format} is declared in the \hyperlink{FE_eqdec_FE_Example_equipment_structure}{Equipment list} , e.g. 
\begin{DoxyCode}
    EQUIPMENT equipment[] = {

      { "Trigger",            // equipment name
        {
          ...
          "Midas",            // format
          ...
      ...  
\end{DoxyCode}


Refer to the following sections for an explanation of event composition depending on the event type selected:
\begin{DoxyItemize}
\item \hyperlink{FE_bank_construction_FE_FIXED_event_readout}{FIXED format Event readout},
\item \hyperlink{FE_bank_construction_FE_MIDAS_event_construction}{MIDAS event construction},
\end{DoxyItemize}

\par
 

 \par
 \label{FE_bank_construction_idx_format_FIXED}
\hypertarget{FE_bank_construction_idx_format_FIXED}{}
 \label{FE_bank_construction_idx_event_readout_format_fixed}
\hypertarget{FE_bank_construction_idx_event_readout_format_fixed}{}
\hypertarget{FE_bank_construction_FE_FIXED_event_readout}{}\subsubsection{FIXED format Event readout}\label{FE_bank_construction_FE_FIXED_event_readout}
The \hyperlink{FE_table_FE_tbl_Format}{FIXED format} is the simplest event format. The event length is fixed and is mapped to a C structure that is filled by the readout routine. Since the standard MIDAS analyzer cannot work with this format, it is only recommended for an experiment which uses its own analyzer and wants to avoid the overhead of a bank structure, or for monitoring purposes in the ODB.

\par
 There are several ways of defining fixed events. For fixed events, the structure has to be defined twice: once for the compiler in the form of a C structure, and once for the ODB in form of an ASCII representation. There are several ways of doing this. The ASCII string may be supplied to the system as the \hyperlink{FE_table_FE_tbl_InitString}{init string} in the equipment list as follows:

\begin{table}[h]\begin{TabularC}{3}
\hline
Example of FIXED format event:   \\\cline{1-1}
{\bfseries Fixed Event Definition} \par
A fixed event with two ADC and TDC values:  &The {\bfseries trigger\_\-event\_\-str} has to be defined before the equipment list and a reference to it has to be placed in the equipment list like:  &The {\bfseries Readout routine} \par
The $<$...$>$ statements are filled with the appropriate code accessing the hardware:  

\\\cline{1-3}

\begin{DoxyCode}
typedef struct {
  int adc0;
  int adc1;
  int tdc0;
  int tdc1;
  TRIGGER_EVENT;
}
char *trigger_event_str[] = {
"adc0 = INT : 0",
"adc1 = INT : 0",
"tdc0 = INT : 0",
"tdc1 = INT : 0",
  ASUM_BANK;
}
\end{DoxyCode}
  &


\begin{DoxyCode}
 {
  "FIXED",            // FIXED format
...
  read_trigger_event, // readout routine 
  NULL,NULL,
  trigger_event_str,  // init string 
 ,
\end{DoxyCode}
 &


\begin{DoxyCode}
INT read_trigger_event(char *pevent)
{
TRIGGER_EVENT *ptrg;

  ptrg = (TRIGGER_EVENT *) pevent;
  ptrg->adc0 = <...>;
  ptrg->adc1 = <...>;
  ptrg->tdc0 = <...>;
  ptrg->tdc1 = <...>;

  return sizeof(TRIGGER_EVENT);
\end{DoxyCode}


\\\cline{1-3}
\end{TabularC}
\centering
\caption{Example of definition of FIXED format using Equipment field \char`\"{}init string\char`\"{} }
\end{table}
\par
 Alternatively, the structure may be defined first in the ODB, under /Equipment/$<$eqp\_\-name$>$/Variables, and supplied to the readout routine by the frontend program including \char`\"{}experim.h\char`\"{}, as follows:

\begin{table}[h]\begin{TabularC}{2}
\hline
C structure from {\itshape \hyperlink{experim_8h}{experim.h}:\/}   &ASCII representation from {\itshape \hyperlink{experim_8h}{experim.h}\/} :   \\\cline{1-2}

\begin{DoxyCode}
#define INFO_ODB_EVENT_DEFINED

typedef struct {
  DWORD     helicity;
  DWORD     current_cycle;
  DWORD     current_scan;
  double    current_hel_thr;
  DWORD     rf_state;
  DWORD     fluor_monitor_counts;
  float     epicsdev_set_v_;
  float     epicsdev_read_v_;
  float     campdev_set;
  float     campdev_read;
  DWORD     last_failed_thr_test;
} INFO_ODB_EVENT;
\end{DoxyCode}
 &
\begin{DoxyCode}
#define INFO_ODB_EVENT_STR(_name)
           char *_name[] = {\
"[.]",\
"helicity = DWORD : 0",\
"current cycle = DWORD : 54",\
"current scan = DWORD : 5",\
"Current Hel thr = DOUBLE : 0",\
"RF state = DWORD : 0",\
"Fluor monitor counts = DWORD : 0",\
"EpicsDev Set(V) = FLOAT : 0",\
"EpicsDev Read(V) = FLOAT : 0",\
"Campdev set = FLOAT : 0",\
"Campdev read = FLOAT : 0",\
"last failed thr test = DWORD : 0",\
"",\
NULL }
\end{DoxyCode}
 \\\cline{1-2}
\end{TabularC}
\centering
\caption{Example of structure from {\bfseries \hyperlink{experim_8h}{experim.h}} for a fixed event }
\end{table}


\label{FE_bank_construction_FE_RO_ODB_example}
\hypertarget{FE_bank_construction_FE_RO_ODB_example}{}
 The \hyperlink{FE_table}{Equipment definition} for this fixed event might be : 
\begin{DoxyCode}
 { "Info ODB",     /* equipment name */
    10, 0,         /* event ID, trigger mask */
    "",            /* no banks sent */
    EQ_PERIODIC,   /* equipment type */
    0,             /* interrupt source */
    "FIXED",       /* format */
    TRUE,          /* enabled */
    RO_RUNNING | RO_ODB | 
          RO_EOR,  /* read when running; 
                      send to odb */
    500,           /* polling period */
    0,             /* event limit */
    0,             /* number of sub-events */
    0,             /* log history */
    "", "", "",
    info_odb,      /* readout routine */
    NULL,NULL,NULL,
  },
\end{DoxyCode}


The \hyperlink{frontend_8c}{frontend.c} program would then include \hyperlink{experim_8h}{experim.h} to gain access to the structure. \par
It is a good idea to check the record size and/or create the record in the odb when using C structures from \hyperlink{experim_8h}{experim.h}, to make sure that the structure is identical in the odb to that in \hyperlink{experim_8h}{experim.h}. \par
 The {\bfseries  main program } might look like this:


\begin{DoxyCode}
/* frontend.c */
....

#include experim.h

INFO_ODB_EVENT cyinfo;
INFO_ODB_EVENT_STR(info_odb_event_str);
HNDLE hInfo;
INT status, size;
char   str_set[256];
....

sprintf(str_set,"/Equipment/INFO ODB/Variables");

/* create record /Equipment/INFO ODB/Variables to make sure it exists  */
 /* find the key for info odb */
  status = db_find_key(hDB, 0, str_set, &hInfo);
  if (status != DB_SUCCESS)
    {
      printf( "Key %s not found; creating record for info odb\n",str_set);
      status = db_create_record(hDB, 0, str_set, strcomb(info_odb_event_str));
    }
  /* check the record size */
  status = db_get_record_size(hDB, hInfo, 0, &size);
  if (sizeof(INFO_ODB_EVENT) != size)
     {
        cm_msg(MERROR, "bnmr_init", "error; record sizes do not match");
        return DB_TYPE_MISMATCH;
     }

  .......    
\end{DoxyCode}


A {\bfseries readout routine} for this fixed event is as follows: 
\begin{DoxyCode}
INT info_odb(char * pevent, INT off)
/* - periodic equipment updating the ODB ONLY
   - no event generation for the data stream.
*/
{

  /* fill various values */
  cyinfo.helicity = gbl_ppg_hel;
  cyinfo.current_cycle = gbl_CYCLE_N;
  cyinfo.current_scan = gbl_SCAN_N;
  cyinfo.epicsdev_set_v_ = epics_params.Epics_val;
  cyinfo.epicsdev_read_v_ = epics_params.Epics_read;
  cyinfo.campdev_set = 0;   
  cyinfo.campdev_read = 0; 
    

  memcpy(pevent, (char *)&(cyinfo.helicity), sizeof(cyinfo));
  pevent += sizeof(cyinfo);
  logMsg ("info_odb %d size:%d\n",gbl_CYCLE_N,sizeof(cyinfo),0,0,0,0);
  return sizeof(cyinfo);
}
\end{DoxyCode}
 \par
 The output from a FIXED event of this type sent to the ODB using \hyperlink{RC_mhttpd_utility}{mhttpd} is shown \hyperlink{RC_mhttpd_status_page_features_RC_mhttpd_eq_variables}{here}.

More {\bfseries examples of FIXED events} can be found in the {\bfseries slow controls device drivers}, for example ../examples/slowcont/frontend.c and ../drivers/class/hv.c

\par
 

 \par
 \label{FE_bank_construction_idx_event_readout_format_midas}
\hypertarget{FE_bank_construction_idx_event_readout_format_midas}{}
 \label{FE_bank_construction_idx_Midas_event-construction}
\hypertarget{FE_bank_construction_idx_Midas_event-construction}{}
 \hypertarget{FE_bank_construction_FE_MIDAS_event_construction}{}\subsubsection{MIDAS event construction}\label{FE_bank_construction_FE_MIDAS_event_construction}
The \hyperlink{FE_Data_format_FE_Midas_format}{MIDAS event format} is a variable length event format. It uses \char`\"{}banks\char`\"{} as subsets of an event. A bank is composed of a bank header followed by the data. The bank header itself is made of 3 fields i.e:
\begin{DoxyItemize}
\item bank name (4 characters)
\item bank type
\item bank length
\end{DoxyItemize}

Usually a bank contains an array of values that logically belong together. For example, an experiment can generate an ADC bank, a TDC bank and a bank with trigger information. The length of a bank can vary from one event to another due to zero suppression from the hardware. Besides the variable data length support of the bank structure, another main advantage is the possibility for the analyzer to add more (calculated) banks during the analysis process to the event in process. After the first analysis stage, the event can contain in addition to the the raw ADC bank, a bank with calibrated ADC values called CADC for example. In this CADC bank the raw ADC values could be offset or gain-\/corrected.



\hypertarget{FE_bank_construction_FE_Midas_Data_Types}{}\paragraph{Midas Data Types}\label{FE_bank_construction_FE_Midas_Data_Types}
Midas defines its own {\bfseries  data types } for OS compatibility. It is suggested that you use them in order to ensure correct compilation when moving code from one OS to another.

{\itshape float\/} and {\itshape double\/} retain OS definition.


\begin{DoxyItemize}
\item BYTE unsigned char
\item WORD unsigned short int (16bits word)
\item DWORD unsigned 32bits word
\item INT signed 32bits word
\item BOOL OS dependent.
\end{DoxyItemize}

When defining a data type either in the frontend code for bank definition or in user code to define ODB variables, Midas requires the use of its own data type declaration. The list below shows the main Type IDentification to be used (refer to \hyperlink{group__mdefineh}{Midas Define} for complete listing):


\begin{DoxyItemize}
\item TID\_\-BYTE unsigned byte 0 255
\item TID\_\-SBYTE signed BYTE -\/128 127
\item TID\_\-CHAR single character 0 255
\item TID\_\-WORD two BYTE 0 65535
\item TID\_\-SHORT signed WORD -\/32768 32767
\item TID\_\-DWORD four bytes 0 2$\ast$$\ast$32-\/1
\item TID\_\-INT signed DWORD -\/2$\ast$$\ast$31 2$\ast$$\ast$31-\/1
\item TID\_\-BOOL four bytes bool 0 1
\item TID\_\-FLOAT four bytes float format
\item TID\_\-DOUBLE eight bytes float format
\end{DoxyItemize}



 \label{FE_bank_construction_idx_Midas_bank}
\hypertarget{FE_bank_construction_idx_Midas_bank}{}
 \hypertarget{FE_bank_construction_FE_creation_Midas_banks}{}\paragraph{Creation of MIDAS banks}\label{FE_bank_construction_FE_creation_Midas_banks}
MIDAS banks are created in the frontend readout code with calls to the MIDAS library. The following routines are available:
\begin{DoxyItemize}
\item \hyperlink{group__bkfunctionc_gac6fadde40824dbf7bd70abedd29be2bd}{bk\_\-init()} , \hyperlink{group__bkfunctionc_gae7cbf587db63fcdf66dd18b29f08b6d2}{bk\_\-init32()} Initializes a bank structure in an event. \par
Note that bk\_\-init32 can be used to reduce the size of very large banks, where the data will fit into a 32-\/bit word
\item \hyperlink{group__bkfunctionc_ga4bb781187e18834136ed8ac368d53413}{bk\_\-create()} Creates a bank with a given name (exactly four characters)
\item \hyperlink{group__bkfunctionc_ga132dc71c8f74b478cdcc59bc1d9f6a26}{bk\_\-close()} Closes a bank previously opened with \hyperlink{group__bkfunctionc_ga4bb781187e18834136ed8ac368d53413}{bk\_\-create()}.
\item \hyperlink{group__bkfunctionc_gafe085ddb11bdcff4ca461224254289ef}{bk\_\-locate()} Locates a bank within an event by its name.
\item \hyperlink{group__bkfunctionc_gab6012589013da85b128d8443501a4a44}{bk\_\-iterate()} Returns bank and data pointers to each bank in the event.
\item \hyperlink{group__bkfunctionc_ga4d8a0ef23239ae478544fa96a0e98a33}{bk\_\-list()} Constructs a string with all the banks' names in the event.
\item \hyperlink{group__bkfunctionc_ga8fc93de36e62c4328cb6581be7f42a0f}{bk\_\-size()} Returns the size in bytes of all banks including the bank headers in an event.
\end{DoxyItemize}

\par
 Examples for VME and CAMAC hardware are shown here.

The VME example reads out a VME ADC module into one MIDAS bank. In the CAMAC example the event will contain two banks: one for the ADC data and one for the TDC data.

\begin{table}[h]\begin{TabularC}{2}
\hline
VME :  &CAMAC :  \\\cline{1-2}

\begin{DoxyCode}
INT read_trigger_event(char *pevent, INT off)
{
#if defined VADC0_CODE
  DWORD  *pdata;
#endif
 evlimit = SERIAL_NUMBER(pevent);

#if defined VADC0_CODE
  /* create structured ADC0 bank */
  bk_create(pevent, "ADC0", TID_DWORD, &pdata);
  v792_EvtCntRead(myvme, VADC0_BASE, &evtcnt);
  /* Read Event */
  v792_EventRead(myvme, VADC0_BASE, pdata, &nentry);
  pdata += nentry;
  bk_close(pevent, pdata);
  v792_DataClear(myvme, VADC0_BASE);
  return bk_size(pevent);
#else
  return 0; /* no event */
#endif


}
\end{DoxyCode}
  &


\begin{DoxyCode}
INT read_trigger_event(char *pevent)
{
WORD *pdata, a;

  // init bank structure 
  bk_init(pevent);

  // create ADC bank 
  bk_create(pevent, "ADC0", TID_WORD, &pdata);

  // read ADC bank 
  for (a=0 ; a<8 ; a++)
    cami(1, 1, a, 0, pdata++);

  bk_close(pevent, pdata);

  // create TDC bank 
  bk_create(pevent, "TDC0", TID_WORD, &pdata);

  // read TDC bank 
  for (a=0 ; a<8 ; a++)
    cami(1, 2, a, 0, pdata++);

  bk_close(pevent, pdata);

  return bk_size(pevent);
\end{DoxyCode}
 \\\cline{1-2}
\end{TabularC}
\centering
\caption{Readout routines showing Midas Bank construction }
\end{table}
\par


Upon normal completion, the readout routine returns the event size in bytes. If the event is not valid, the routine can return zero. In this case no event is sent to the back-\/end. This can be used to implement a software event filter (sometimes called \char`\"{}third level trigger\char`\"{}).

Examples of unpacking the data from Midas banks are shown in the \hyperlink{DataAnalysis}{SECTION 7: Data Analysis} section.

\par
 

 \par
\hypertarget{FE_bank_construction_FE_Midas_Event_Header_Manipulation}{}\paragraph{Midas Event header manipulation}\label{FE_bank_construction_FE_Midas_Event_Header_Manipulation}
\label{FE_bank_construction_FE_Midas_Event_Header_Macros}
\hypertarget{FE_bank_construction_FE_Midas_Event_Header_Macros}{}
 Every event travelling through the Midas system has a \char`\"{}Event Header\char`\"{} containing the minimum information required to identify its contents. The size of the header has been kept as small as possible in order to minimize its impact on the data rate as well as on the data storage requirment. The following Macros in the \hyperlink{F_Midas_Code_and_Libraries_F_Midas_Library}{MIDAS Code and Libraries} are available for manipulating Midas event headers. They permit reading or overrideing the content of the event header, as long as the argument of the macro refers to the top of the Midas event (pevent). This argument (pevent) is available in the frontend code in any of the user readout functions.

The Macros are also available to the user analyzer code, which retrieves the event and provide direct access to the event header (pheader) and to the user part of the event (pevent). Sub-\/functions using pevent would then be able to get back the header through the use of the macros.


\begin{DoxyItemize}
\item \hyperlink{group__mbufferh_ga6a0d6be5b8aad5a907d5b880bae93eb9}{TRIGGER\_\-MASK}
\item \hyperlink{group__mbufferh_gaf42c9a1ac33cf459bfd366673f6a4d70}{EVENT\_\-ID}
\item \hyperlink{group__mbufferh_gadbb75a9d81e264e357bc5fc73dd4ebb8}{SERIAL\_\-NUMBER}
\item \hyperlink{group__mbufferh_gae8d2f03c283637c81cdcfd3fda065d53}{TIME\_\-STAMP}
\end{DoxyItemize}

\label{FE_bank_construction_timestamp}
\hypertarget{FE_bank_construction_timestamp}{}
 The following frontend C-\/code fragments from a running experiment demonstrate the use of these Macros :
\begin{DoxyItemize}
\item example 1 
\begin{DoxyCode}
INT read_ge_event(char *pevent, INT offset)
{
  static WORD *pdata;
  INT i, x, q;
  WORD temp;
 
  // Change the time stamp in millisecond for the Super event
  TIME_STAMP(pevent) = ss_millitime();
  
  bk_init(pevent);
  bk_create(pevent, "GERM", TID_WORD, &pdata);
  ...
}
\end{DoxyCode}

\end{DoxyItemize}


\begin{DoxyItemize}
\item example 2
\end{DoxyItemize}


\begin{DoxyCode}
  ...
  lam = *((DWORD *)pevent);

  if (lam & LAM_STATION(JW_N))

  {
    ...
    // compose event header
    TRIGGER_MASK(pevent) = JW_MASK;
    EVENT_ID(pevent)     = JW_ID;
    SERIAL_NUMBER(pevent)= eq->serial_number++;
    // read MCS event
    size = read_mcs_event(pevent);
    // Correct serial in case event is empty 
    if (size == 0)
      SERIAL_NUMBER(pevent) = eq->serial_number--;
    ...
  }
  ...
\end{DoxyCode}




 \par




\par
 \label{index_end}
\hypertarget{index_end}{}
 \subsubsection{Super-\/Event}\label{FE_Super_Event}
\par
 

\par
 \label{FE_Super_Event_idx_event_readout_super-event}
\hypertarget{FE_Super_Event_idx_event_readout_super-event}{}
 \label{FE_Super_Event_idx_super-event}
\hypertarget{FE_Super_Event_idx_super-event}{}


The Super-\/Event is an option implemented in the frontend code in order to reduce the amount of data to be transfered to the backend computer(s) by removing the bank header for each event constructed. It is not applicable to FIXED format events.

In other words, when an equipment readout in {\itshape MIDAS\/} bank format is complete, the event is composed of the bank header followed by the data section.

The overhead in bytes of the bank structure is 16 bytes for \hyperlink{group__bkfunctionc_gac6fadde40824dbf7bd70abedd29be2bd}{bk\_\-init()}, 20 bytes for \hyperlink{group__bkfunctionc_gae7cbf587db63fcdf66dd18b29f08b6d2}{bk\_\-init32()} and ybk\_\-init(). If the data section size is close to the number above, the data transfer as well as the data storage has an non-\/negligible overhead. To address this problem, the equipment can be set up to generate a so called {\bfseries  Super-\/Event } which is an event composed of the initial standard bank header for the first event of the super-\/event, and up to the \hyperlink{FE_table_FE_tbl_NumSubevents}{number of sub-\/events} maximum successive data sections before the closing of the bank.\hypertarget{FE_Super_Event_FE_Super_Event_example}{}\subsubsection{Super-\/Event Example}\label{FE_Super_Event_FE_Super_Event_example}
To demonstrate the use of the super-\/event, consider the following example:


\begin{DoxyItemize}
\item Define equipment to be able to generate the {\bfseries Super-\/Event} 
\begin{DoxyCode}
  { "GE",                 // equipment name 
      2, 0x0002,            // event ID, trigger mask 
      "SYSTEM",             // event buffer 
  #ifdef USE_INT
      EQ_INTERRUPT,         // equipment type 
  #else
      EQ_POLLED,            // equipment type 
  #endif
      LAM_SOURCE(GE_C, LAM_STATION(GE_N)), // interrupt source 
      "MIDAS",              // format 
      TRUE,                 // enabled 
      RO_RUNNING,           // read only when running 
      200,                  // poll for 200ms 
      0,                    // stop run after this event limit 
      1000,                 // -----> number of sub events <-----  enable Super-e
      vent
      0,                    // don't log history 
      "", "", "",
      read_ge_event,        // readout routine 
       ,
      ...
\end{DoxyCode}

\end{DoxyItemize}\hypertarget{FE_Super_Event_FE_Super_Event_readout}{}\subsubsection{Example Readout code for Super-\/Event}\label{FE_Super_Event_FE_Super_Event_readout}
Set up the readout function for Super-\/Event collection, e.g. 
\begin{DoxyCode}
  //-- Event readout
  // Global and fixed -- Expect NWORDS 16bits data readout per sub-event
  #define NWORDS 3

  INT read_ge_event(char *pevent, INT offset)
  {
    static WORD *pdata;

    // Super-event structure 
    if (offset == 0)
    {
      // FIRST event of the Super-event 
      bk_init(pevent);
      bk_create(pevent, "GERM", TID_WORD, &pdata);

    else if (offset == -1)
    {
      // close the Super-event if offset is -1
      bk_close(pevent, pdata);

      // End of Super-Event
      return bk_size(pevent);


    // read GE sub-event (ADC) 
    cam16i(GE_C, GE_N, 0, GE_READ, pdata++);
    cam16i(GE_C, GE_N, 1, GE_READ, pdata++);
    cam16i(GE_C, GE_N, 2, GE_READ, pdata++);

    // clear hardware 
    re_arm_ge(); 

    if (offset == 0)
    {
      // Compute the proper event length on the FIRST event in the Super-Event
      // NWORDS correspond to the !! NWORDS WORD above !!
      // sizeof(BANK_HEADER) + sizeof(BANK) will make the 16 bytes header
      // sizeof(WORD) is defined by the TID_WORD in bk_create()

      return NWORDS * sizeof(WORD) + sizeof(BANK_HEADER) + sizeof(BANK);

    else
      // Return the data section size only
      // sizeof(WORD) is defined by the TID_WORD in bk_create()

      return NWORDS * sizeof(WORD);
\end{DoxyCode}
 \par


As shown in the example above: 
\begin{DoxyItemize}
\item For the {\bfseries first} event, the correct size of the event {\bfseries including the header} must be calculated and returned 
\item {\bfseries Subsequent} events return the size of the {\bfseries data only}, not the header. 
\end{DoxyItemize}

The input parameter \char`\"{}offset\char`\"{} is used to indicate whether the event is the first, last or intermediate. After the last event, the bank is closed. \par
 The encoding of the data section is left to the user. If the number of words per sub-\/event is fixed (i.e. NWORDS in the above example), the sub-\/event extraction by an analyzer is simple. In the case of variable sub-\/event length, it is necessary to tag the first or the last word of each sub-\/event.The contents of the sub-\/event is the choice of the user.

{\bfseries Note:} 
\begin{DoxyItemize}
\item Since no particular tagging is applied to the Super-\/Event by the Midas transfer mechanism, {\itshape  the user must provide code in the backend analyzer to interpret the contents of the Super-\/Event bank(s)\/}.
\end{DoxyItemize}


\begin{DoxyItemize}
\item If the Super-\/Event is composed by an equipment on a remote processor running a different {\itshape Endian\/} mode than the backend processor, it would be necessary to {\itshape ensure the data type consistency throughout the {\bfseries  Super-\/Event } \/} in order to guarantee the proper byte-\/swapping of the data content. \hyperlink{DataAnalysis_DA_Byte_Swap_Macros}{Byte Swap Macros} are available for this purpose.
\end{DoxyItemize}


\begin{DoxyItemize}
\item It may be convenient to change the {\bfseries time-\/stamp} of the super-\/event (see \hyperlink{FE_bank_construction_timestamp}{example} of use of Macro)
\end{DoxyItemize}


\begin{DoxyItemize}
\item The {\bfseries  event rate } in the equipment statistics will {\itshape  indicate the rate of sub-\/events\/}.
\end{DoxyItemize}

\par
 

\par
 \label{index_end}
\hypertarget{index_end}{}
 \subsubsection{Event Builder Functions}\label{FE_Event_Builder}
\par
 

\par
 \label{FE_Event_Builder_idx_mevb-utility}
\hypertarget{FE_Event_Builder_idx_mevb-utility}{}
 \label{FE_Event_Builder_idx_event_builder_utility-see-mevb}
\hypertarget{FE_Event_Builder_idx_event_builder_utility-see-mevb}{}




 \hypertarget{FE_Event_Builder_FE_mevb_utility}{}\subsubsection{mevb -\/ event builder utility}\label{FE_Event_Builder_FE_mevb_utility}
{\bfseries mevb} is an event builder application which takes the MIDAS data output from several frontends, and assembling them into a new overall MIDAS event. Two types of event builder can be envisaged:
\begin{DoxyItemize}
\item Asynchronized data collection
\begin{DoxyItemize}
\item Synchronized data collection In the case where overall data collection is handled by multiple physically separated frontends, it could be necessary to assemble these data fragments into a dedicated event. The synchonization of the fragment collection is left to the user, which is done usually through a specific hardware mechanism. Once the fragments are composed in each frontend, they are sent to the \char`\"{}Event Builder\char`\"{} (eb) where the serial number (pheader-\/$>$serial\_\-number) of each fragment is compared one event at a time for serial match. In case of a match, a new event will be composed with its own event ID and serial number, followed by all the expected event fragments. The composed event is then sent to the next stage which is usually the data logger (mlogger).
\end{DoxyItemize}
\end{DoxyItemize}

The \hyperlink{RC_mhttpd_utility}{The mhttpd daemon} will present the status of the event builder as an extra equipment with its corresponding statistical information.


\begin{DoxyItemize}
\item {\bfseries  Arguments }
\begin{DoxyItemize}
\item \mbox{[}-\/h \mbox{]} : help
\item \mbox{[}-\/h hostname \mbox{]} : host name
\item \mbox{[}-\/e exptname \mbox{]} : experiment name
\item \mbox{[}-\/i index \mbox{]} : equipment index identification
\item \mbox{[}-\/b buffer\_\-name \mbox{]} : Buffer name
\item \mbox{[}-\/v \mbox{]} : Show wheel
\item \mbox{[}-\/d \mbox{]} : debug messages
\item \mbox{[}-\/D \mbox{]} : start program as a daemon
\end{DoxyItemize}
\item {\bfseries  Usage } 
\begin{DoxyCode}
  Thu> mevb -e midas
  Program mevb/EBuilder version 2 started
\end{DoxyCode}

\end{DoxyItemize}

\par


\par
 \label{FE_Event_Builder_idx_event_builder}
\hypertarget{FE_Event_Builder_idx_event_builder}{}
\hypertarget{FE_Event_Builder_FE_eb}{}\subsubsection{Introduction to Event building in MIDAS}\label{FE_Event_Builder_FE_eb}
MIDAS supports event building through a dedicated \hyperlink{FE_Event_Builder_FE_mevb_utility}{mevb -\/ event builder utility} application. Similar to the \hyperlink{FrontendOperation_FE_frontend_utility}{frontend -\/ MIDAS Frontend application}, the {\bfseries mevb} application requires the definition of an equipment structure which describes its mode of operation. \par
The set of parameter for this equipment is limited to:
\begin{DoxyItemize}
\item Equipment name (appears in the Equipment list).
\item Equipment type (should be 0).
\item Destination buffer name (SYSTEM if destination event goes to logger).
\item Event ID and Trigger mask for the build event (destination event ID).
\item Data format (should match the source data format).
\end{DoxyItemize}

Based on the given buffer name provided at the startup time through the {\itshape  -\/b buffer\_\-name \/} argument, the \hyperlink{FE_Event_Builder_FE_mevb_utility}{mevb task}, will scan all the equipments and handle the building of an event based on the identical buffer name found in the equipment list {\bfseries  if the frontend equipment type includes the \hyperlink{FE_table_FE_tbl_EqEb}{EQ\_\-EB} flag }.

that the \char`\"{}event fragments\char`\"{} used by the event builder are not to be confused with the \hyperlink{FE_eq_event_routines_FE_fragmented_event}{fragmented event} mechanism.

\label{FE_Event_Builder_idx_event_fragment}
\hypertarget{FE_Event_Builder_idx_event_fragment}{}
 \hypertarget{FE_Event_Builder_FE_principle_eb}{}\subsubsection{Principle of the Event Builder and related frontend fragment}\label{FE_Event_Builder_FE_principle_eb}
It is possible that in case of multiple frontends, the same \char`\"{}fragment\char`\"{} code may run in the different hardware frontends. In order to prevent having to build nFragment different frontend tasks, the {\bfseries  \char`\"{}-\/i index\char`\"{} } argument given when starting the \hyperlink{FrontendOperation_FE_frontend_utility}{frontends} will replicate the same application image with the necessary dynamic modification required for the proper Event Building operation.

The index can be passed to the frontend application either by this argument, or by environment variable. \hyperlink{BuildingOptions_BO_MIDAS_FRONTEND_INDEX}{MIDAS\_\-FRONTEND\_\-INDEX}.

The \char`\"{}-\/i index\char`\"{} argument will provide the index to be appended to the minimal set of \hyperlink{structparameters}{parameters} to distinguish the different frontends. These \hyperlink{structparameters}{parameters} are:
\begin{DoxyItemize}
\item {\bfseries frontend\_\-name} : Name of the frontend application.
\item {\bfseries equipment} {\bfseries name} : Name of the equipment (from the Equipment structure).
\item {\bfseries event} {\bfseries buffer:} Name of the destination buffer (from the Equipment structure).
\end{DoxyItemize}

To allow either synchronized fragment collection or asynchronized gathering of the fragments, the composition of the \char`\"{}event buffer\char`\"{} and \char`\"{}equipment name\char`\"{} require to have the index format part of the equipment definition in the case of the synchronized fragment event builder. 

Frontend code for asynchronized fragment collection in the event builder, Event buffer remains the same for all the fragments: 
\begin{DoxyCode}
  /* The frontend name (client name) as seen by other MIDAS clients   */
  char *frontend_name = "ebfe";
  ...
   EQUIPMENT equipment[] = {

      {"Trigger%02d",              /* equipment name */
       1, TRIGGER_ALL,         /* event ID, trigger mask */
       "BUFFER",                  /* event buffer */
       EQ_POLLED | EQ_EB,       /* equipment type + EQ_EB flag <<<<<< */
       LAM_SOURCE(0, 0xFFFFFF), /* event source crate 0, all stations */
       "MIDAS",                 /* format */
\end{DoxyCode}
 

Frontend code for synchronized fragment collection in the event buider: 
\begin{DoxyCode}
  /* The frontend name (client name) as seen by other MIDAS clients   */
  char *frontend_name = "ebfe";
  ...
   EQUIPMENT equipment[] = {

      {"Trigger%02d",              /* equipment name */
       1, TRIGGER_ALL,         /* event ID, trigger mask */
       "BUF%02d",                  /* event buffer */
       EQ_POLLED | EQ_EB,       /* equipment type + EQ_EB flag <<<<<< */
       LAM_SOURCE(0, 0xFFFFFF), /* event source crate 0, all stations */
       "MIDAS",                 /* format */
\end{DoxyCode}


Once the frontend is started with {\itshape  -\/i 1 \/}, the MIDAS client name, equipment name and buffer name will be modified (case of the synchronized event builder).


\begin{DoxyCode}
> ebfe -i 1 -D
...
odbedit
[local:midas:S]/Equipment>ls
Trigger01
[local:midas:S]Trigger01>ls -lr
Key name                        Type    #Val  Size  Last Opn Mode Value
---------------------------------------------------------------------------
Trigger01                       DIR
    Common                      DIR
        Event ID                WORD    1     2     18h  0   RWD  1
        Trigger mask            WORD    1     2     18h  0   RWD  65535
        Buffer                  STRING  1     32    18h  0   RWD  BUF01
        Type                    INT     1     4     18h  0   RWD  66
        Source                  INT     1     4     18h  0   RWD  16777215
        Format                  STRING  1     8     18h  0   RWD  MIDAS
        Enabled                 BOOL    1     4     18h  0   RWD  y
        Read on                 INT     1     4     18h  0   RWD  257
        Period                  INT     1     4     18h  0   RWD  500
        Event limit             DOUBLE  1     8     18h  0   RWD  0
        Num subevents           DWORD   1     4     18h  0   RWD  0
        Log history             INT     1     4     18h  0   RWD  0
        Frontend host           STRING  1     32    18h  0   RWD  hostname
        Frontend name           STRING  1     32    18h  0   RWD  ebfe01
        Frontend file name      STRING  1     256   18h  0   RWD  .../eventbuilde
      r/ebfe.c
...
\end{DoxyCode}


Independently of the event ID, each fragment frontend will send its data to the composed event buffer (BUFxx). The event builder task will make up a list of all the equipment belonging to the same event buffer name (BUFxx). If multiple equipments exists in the same frontend, the equipment type (EQ\_\-EB) and the event buffer name will distinguish them.

\label{FE_Event_Builder_idx_event_builder_flowchart}
\hypertarget{FE_Event_Builder_idx_event_builder_flowchart}{}
 The Event Builder flowchart below shows a general picture of the event process cycle of the task. The Event Builder runs in polling mode over all the source buffers collected at the begin of run procedure. Once a fragment has been received from all enabled source (\char`\"{}../Settings/Fragment Required y\char`\"{}), an internal event serial number check is performed prior passing all the fragment to the user code. Content of each fragment can be done within the user code for further consistency check.

\begin{center} Event Builder Flowchart.  \end{center} 

\label{FE_Event_Builder_idx_ODB_tree_event-builder}
\hypertarget{FE_Event_Builder_idx_ODB_tree_event-builder}{}




 \hypertarget{FE_Event_Builder_FE_ODB_EBuilder_Tree}{}\subsubsection{The ODB Event Builder Tree}\label{FE_Event_Builder_FE_ODB_EBuilder_Tree}
\begin{Desc}
\item[\hyperlink{todo__todo000001}{Todo}]Event Builder tree -\/ there are two versions that need combining !!\end{Desc}
The Event Builder tree is created by \hyperlink{FE_Event_Builder_FE_mevb_utility}{mevb -\/ event builder utility} and is placed in the Equipment list.


\begin{DoxyCode}
Key name                        Type    #Val  Size  Last Opn Mode Value
---------------------------------------------------------------------------
EBuilder                        DIR
    Settings                    DIR
        Event ID                WORD    1     2     65h  0   RWD  1
        Trigger mask            WORD    1     2     65h  0   RWD  1
        Buffer                  STRING  1     32    65h  0   RWD  SYSTEM
        Format                  STRING  1     32    65h  0   RWD  MIDAS
        Event mask              DWORD   1     4     65h  0   RWD  3
        hostname                STRING  1     64    3h   0   RWD  myhost
    Statistics                  DIR
        Events sent             DOUBLE  1     8     3h   0   RWD  653423
        Events per sec.         DOUBLE  1     8     3h   0   RWD  1779.17
        kBytes per sec.         DOUBLE  1     8     3h   0   RWD  0
    Channels                    DIR
        Frag1                   DIR
            Settings            DIR
                Event ID        WORD    1     2     65h  0   RWD  1
                Trigger mask    WORD    1     2     65h  0   RWD  65535
                Buffer          STRING  1     32    65h  0   RWD  BUF1
                Format          STRING  1     32    65h  0   RWD  MIDAS
                Event mask      DWORD   1     4     65h  0   RWD  1
            Statistics          DIR
                Events sent     DOUBLE  1     8     3h   0   RWD  653423
                Events per sec. DOUBLE  1     8     3h   0   RWD  1779.17
                kBytes per sec. DOUBLE  1     8     3h   0   RWD  0
        Frag2                   DIR
            Settings            DIR
                Event ID        WORD    1     2     65h  0   RWD  5
                Trigger mask    WORD    1     2     65h  0   RWD  65535
                Buffer          STRING  1     32    65h  0   RWD  BUF2
                Format          STRING  1     32    65h  0   RWD  MIDAS
                Event mask      DWORD   1     4     65h  0   RWD  2
            Statistics          DIR
                Events sent     DOUBLE  1     8     3h   0   RWD  653423
                Events per sec. DOUBLE  1     8     3h   0   RWD  1779.17
                kBytes per sec. DOUBLE  1     8     3h   0   RWD  0
\end{DoxyCode}
\hypertarget{FE_Event_Builder_FE_eb_tree_2}{}\subsubsection{Event builder ODB Tree (version 2)}\label{FE_Event_Builder_FE_eb_tree_2}
\begin{Desc}
\item[\hyperlink{todo__todo000002}{Todo}]Is the tree /EB or /EBuilder as above ??\end{Desc}
The Event builder tree will be created under the Equipment list and will appear as a standard equipment. The sub tree {\itshape /Common\/} will contains the specific setting of the equipment while the {\itshape /Variables\/} will remain empty. {\itshape /Settings\/} will have particular parameter for the Event Builder itself. The {\bfseries  User Field } is an ASCII string passed from the ODB to the \hyperlink{mevb_8c_aac338f16c26978fda836e729d5c6e366}{eb\_\-begin\_\-of\_\-run()} which can be used for steering the event builder.


\begin{DoxyCode}
[local:midas:S]EB>ls -lr
Key name                        Type    #Val  Size  Last Opn Mode Value
---------------------------------------------------------------------------
EB                              DIR
    Common                      DIR
        Event ID                WORD    1     2     5m   0   RWD  1
        Trigger mask            WORD    1     2     5m   0   RWD  0
        Buffer                  STRING  1     32    5m   0   RWD  SYSTEM
        Type                    INT     1     4     5m   0   RWD  0
        Source                  INT     1     4     5m   0   RWD  0
        Format                  STRING  1     8     5m   0   RWD  MIDAS
        Enabled                 BOOL    1     4     5m   0   RWD  y
        Read on                 INT     1     4     5m   0   RWD  0
        Period                  INT     1     4     5m   0   RWD  0
        Event limit             DOUBLE  1     8     5m   0   RWD  0
        Num subevents           DWORD   1     4     5m   0   RWD  0
        Log history             INT     1     4     5m   0   RWD  0
        Frontend host           STRING  1     32    5m   0   RWD  hostname
        Frontend name           STRING  1     32    5m   0   RWD  Ebuilder
        Frontend file name      STRING  1     256   5m   0   RWD  c:\...\ebuser.c
      
    Variables                   DIR
    Statistics                  DIR
        Events sent             DOUBLE  1     8     3s   0   RWDE 944
        Events per sec.         DOUBLE  1     8     3s   0   RWDE 0
        kBytes per sec.         DOUBLE  1     8     3s   0   RWDE 0
    Settings                    DIR
        Number of Fragment      INT     1     4     9s   0   RWD  2
        User build              BOOL    1     4     9s   0   RWD  n
        User Field              STRING  1     64    9s   0   RWD  100
        Fragment Required       BOOL    2     4     9s   0   RWD
                                        [0]             y
                                        [1]             y
\end{DoxyCode}
\hypertarget{FE_Event_Builder_FE_eb_Operation}{}\subsubsection{Event Builder Operation}\label{FE_Event_Builder_FE_eb_Operation}
Using the \char`\"{}eb$>$\char`\"{} as the current working directory (cwd) for the example, the test procedure is the following: cwd : midas/examples/eventbuilder -\/$>$ referred to as eb$>$


\begin{DoxyItemize}
\item Build the mevb task: 
\begin{DoxyCode}
eb> setenv MIDASSYS /home/midas/midas-1.9.5
eb> make
cc  -g -I/usr/local/include -I../../drivers -DOS_LINUX -Dextname -c ebuser.c
cc  -g -I/usr/local/include -I../../drivers -DOS_LINUX -Dextname -o mevb mevb.c \
      
          ebuser.o /usr/local/lib/libmidas.a  -lm -lz -lutil -lnsl
cc  -g -I/usr/local/include -I../../drivers -DOS_LINUX -Dextname \
          -c ../../drivers/bus/camacnul.c
cc  -g -I/usr/local/include -I../../drivers -DOS_LINUX -Dextname -o ebfe \
        ebfe.c camacnul.o /usr/local/lib/mfe.o /usr/local/lib/libmidas.a \
        -lm -lz -lutil -lnsl
eb>
\end{DoxyCode}

\item Start the following 4 applications in 4 differents windows connecting to a defined experiment. -\/-\/ If no experiment defined yet, set the environment variable MIDAS\_\-DIR to your current directory before spawning the windows. 
\begin{DoxyCode}
xterm1: eb> ebfe -i 1 
xterm2: eb> ebfe -i 2 
xterm3: eb> mevb -b BUF
xterm4: eb> odbedit

[local:Default:S]/>ls
System                          
Programs                        
Experiment                      
Logger                          
Runinfo                         
Alarms                          
Equipment                       
[local:Default:S]/>scl
N[local:midas:S]EB>scl
Name                Host
ebfe01              hostname
ebfe02              hostname
ODBEdit             hostname
Ebuilder            hostname
[local:Default:S]/>
[local:Default:S]/>start now
Starting run #2
\end{DoxyCode}

\end{DoxyItemize}


\begin{DoxyItemize}
\item The xterm3 (mevb) should display something equivalent to the following, as the print statements are coming from the ebuser code.
\end{DoxyItemize}

\begin{Desc}
\item[\hyperlink{todo__todo000003}{Todo}]This eb example 1 is missing!!\end{Desc}
-\/ The same procedure can be repeated with the fe1 and fe2 started on remote nodes.

\begin{Desc}
\item[\hyperlink{todo__todo000004}{Todo}]This eb example 2 is missing!!\end{Desc}
\par
 

\par
 \label{index_end}
\hypertarget{index_end}{}
 \subsubsection{Slow Control System}\label{FE_Slow_Control_system}
\label{FE_Slow_Control_system_idx_slow-control_system}
\hypertarget{FE_Slow_Control_system_idx_slow-control_system}{}
 \par
 

\par


Slow Control Systems are used for setup and monitoring of hardware that is not time-\/critical, and can be run at a low priority. Slow Control systems in a typical experiment are often used to setup and/or monitor components such as high voltage modules, temperature sensors, pressure gauges, leak detectors, RF generators, PID controllers etc. often from a large number of hardware vendors.

In the Midas Slow Control System, instead of talking directly to each other, frontend and control programs exchange information through the ODB. If several types of hardware are to be included in a Slow Control System, they may be assigned to a separate Slow Control Equipments. Each Slow Control Equipment is assigned a corresponding ODB subtree under /Equipment. This tree contains variables needed to control the equipment as well as variables measured by the equipment.

In the case of a high voltage equipment this is
\begin{DoxyItemize}
\item a {\bfseries Demand} array which contains voltages to be set,
\item a {\bfseries Measured} array which contains read back voltages and
\item a {\bfseries Current} array which contains the current drawn from each channel.
\end{DoxyItemize}

To change the voltage of a channel, a control program writes the desired value to the Demand array. This array is connected to the high voltage frontend via an ODB \hyperlink{RC_Hot_Link}{hot-\/link}. Each time the Demand value is modified, the frontend receives a notification and sets the new value. In the other direction, the frontend continuously reads the voltage and current values from all channels and updates the appropriate ODB array(s) if there has been a significant change.

This design has a possible drawback due to the fact that the ODB is the key element of that control. Any failure or corruption of the database can result in incorrect driver control. Therefore it is not recommended to use this system to control systems that need redundancy for safety purposes. On the other hand, this system has several advantages:


\begin{DoxyItemize}
\item The control program does not need any knowledge of the frontend, it only talks to the ODB.
\item The control variables only exist at one place that guarantees consistency among all clients.
\item Basic control can be done through \hyperlink{RC_odbedit_utility}{ODBEdit} (or using mhttpd \hyperlink{RC_mhttpd_ODB_page}{ODB page}) without the need of a special control program.
\item A special control program can be tested without having a frontend running.
\item In case of n frontend and m control programs, only n+m network connections are needed instead of n$\ast$m connection for point-\/to-\/point connections.
\end{DoxyItemize}

Since all slow control values are contained in the ODB, they are automatically dumped to the logging channels. The slow control frontend uses the same framework as the normal frontend, and behaves similarly in many respects. They also create periodic events that contain the slow control variables and are logged together with trigger and scaler events. The only difference is that a routine is called periodically from the framework that has the task of reading channels and updating the ODB. \par
 \label{FE_Slow_Control_system_idx_slow-control_drivers}
\hypertarget{FE_Slow_Control_system_idx_slow-control_drivers}{}
 To access slow control hardware, a two-\/layer driver concept is used. The upper layer is a {\bfseries \char`\"{}class driver\char`\"{}}, which establishes the connection to the ODB variables and contains high level functionality like channel limits, ramping etc. It uses a {\bfseries \char`\"{}device driver\char`\"{}} to access the channels. These drivers implement only very simple commands like \char`\"{}set channel\char`\"{} and \char`\"{}read channel\char`\"{}. The device drivers themselves can use bus drivers like RS232 or GPIB to control the actual device.

\begin{center}  Class driver, Device and Bus driver in the slow control system \par
\par
\par
  \end{center}  \par
\par
\par


The separation into class and device drivers has the advantage that it is very easy to add new devices, because only the simple device driver needs to be written. All higher functionality is inherited from the class driver. The device driver can implement richer functionality, depending on the hardware. For some high voltage devices there is a current read-\/back for example. This is usually reflected by additional variables in the ODB, i.e. a Current array. Frontend equipment uses exactly one class driver, but a class driver can use more than one device driver. This makes it possible to control several high voltage devices for example with one frontend in one equipment. The number of channels for each device driver is defined in the slow control frontend. Several equipments with different class drivers can be defined in a single frontend.

Slow Control variables can be accessed later through the web using the mhttpd \hyperlink{RC_mhttpd_Equipment_page}{Equipment page} and  the new \hyperlink{RC_mhttpd_MSCB_page}{MSCB Page} (since \hyperlink{NDF_ndf_dec_2009}{Dec 2009}) .

This can be done by setting the variable names under the Settings subdirectory of the corresponding Equipment in the ODB. The variable description is given under \hyperlink{F_History_logging_F_History_System}{MIDAS History System} . The \hyperlink{RC_mhttpd_History_page}{History page} will also be automatically activated if the \hyperlink{F_Logging_F_mlogger_utility}{mlogger utility} is running.


\begin{DoxyCode}
Key name                        Type    #Val  Size  Last Opn Mode Value
---------------------------------------------------------------------------
Epics                           DIR
    Settings                    DIR
        Channels                DIR
            Epics               INT     1     4     25h  0   RWD  3
        Devices                 DIR
            Epics               DIR
                Channel name    STRING  10    32    25h  0   RWD  
                                        [0]             GPS:VAR1
                                        [1]             GPS:VAR2
                                        [2]             GPS:VAR3
        Names                   STRING  10    32    17h  1   RWD  
                                        [0]             Current
                                        [1]             Voltage
                                        [2]             Watchdog
        Update Threshold MeasureFLOAT   10    4     17h  0   RWD  
                                        [0]             2
                                        [1]             2
                                        [2]             2
    Common                      DIR
        Event ID                WORD    1     2     17h  0   RWD  3
        Trigger mask            WORD    1     2     17h  0   RWD  0
        Buffer                  STRING  1     32    17h  0   RWD  SYSTEM
        Type                    INT     1     4     17h  0   RWD  4
        Source                  INT     1     4     17h  0   RWD  0
        Format                  STRING  1     8     17h  0   RWD  FIXED
        Enabled                 BOOL    1     4     17h  0   RWD  y
        Read on                 INT     1     4     17h  0   RWD  121
        Period                  INT     1     4     17h  0   RWD  60000
        Event limit             DOUBLE  1     8     17h  0   RWD  0
        Num subevents           DWORD   1     4     17h  0   RWD  0
        Log history             INT     1     4     17h  0   RWD  1
        Frontend host           STRING  1     32    17h  0   RWD  hostname
        Frontend name           STRING  1     32    17h  0   RWD  Epics
        Frontend file name      STRING  1     256   17h  0   RWD  feepic.c
    Variables                   DIR
        Demand                  FLOAT   10    4     0s   1   RWD  
                                        [0]             1.56
                                        [1]             120
                                        [2]             87
        Measured                FLOAT   10    4     2s   0   RWD  
                                        [0]             1.56
                                        [1]             120
                                        [2]             87
    Statistics                  DIR
        Events sent             DOUBLE  1     8     17h  0   RWDE 26
        Events per sec.         DOUBLE  1     8     17h  0   RWDE 0
        kBytes per sec.         DOUBLE  1     8     17h  0   RWDE 0
\end{DoxyCode}


\begin{Desc}
\item[\hyperlink{todo__todo000014}{Todo}]more recent examples, description needed for slow control system\end{Desc}
Example of readout code:


\begin{DoxyCode}
    ...
    "FIXED",                   /* format */
    ...
    cd_hv_read,                 /* readout routine */
    cd_hv,                      /* class driver main routine */
    hv_driver,                  /* device driver list */
    NULL,                       /* init string */
    },


INT cd_hv_read(char *pevent, int offset)
{
   float *pdata;
   DWORD *pdw;
   HV_INFO *hv_info;
   EQUIPMENT *pequipment;

   pequipment = *((EQUIPMENT **) pevent);
   hv_info = (HV_INFO *) pequipment->cd_info;

   if (hv_info->format == FORMAT_FIXED) {
      memcpy(pevent, hv_info->demand, sizeof(float) * hv_info->num_channels);
      pevent += sizeof(float) * hv_info->num_channels;

    memcpy(pevent, hv_info->measured, sizeof(float) * hv_info->num_channels);
      pevent += sizeof(float) * hv_info->num_channels;

      memcpy(pevent, hv_info->current, sizeof(float) * hv_info->num_channels);
      pevent += sizeof(float) * hv_info->num_channels;

      return 3 * sizeof(float) * hv_info->num_channels;
   }
 ....
}
\end{DoxyCode}
 \par


\par
 

\par


\label{index_end}
\hypertarget{index_end}{}
 \subsubsection{Increase the Event Buffer Size(s)}\label{FE_event_buffer_size}
\par
 

\par
 \label{FE_event_buffer_size_idx_buffer_size_increase}
\hypertarget{FE_event_buffer_size_idx_buffer_size_increase}{}
 \label{FE_event_buffer_size_customize_buffer_sizes}
\hypertarget{FE_event_buffer_size_customize_buffer_sizes}{}
 By default the event buffer (used to contain the data from the event) is named {\itshape SYSTEM\/}. Its default size is 2MB. The memory usage can be optimized at the frontend level in case large data transfer is needed. This method works for all MIDAS buffers, except for the ODB buffer, where the size has to be specified at creation time (see \hyperlink{RC_odbedit_examples_RC_odbedit_create_ODB}{ODB Creation}). \par
 There is no need to increase the SYSMSG.SHM buffer as it is used only for messages. \par
 To increase the size of the event buffer(s):


\begin{DoxyEnumerate}
\item Shutdown all MIDAS programs, and \hyperlink{RC_odbedit_examples_RC_odbedit_save}{save the ODB contents} if necessary.
\item Delete the old .SYSTEM.SHM files located in the directory specified by the \hyperlink{Q_Linux_Q_Linux_Exptab}{exptab file} for your experiment. (use {\bfseries ipcrm} (linux) for shared memory segment removal).
\item Run odbedit (which \hyperlink{RC_odbedit_examples_RC_odbedit_create_ODB}{creates the ODB}). 
\begin{DoxyCode}
$odbedit
[local:midas:Stopped]/>cd /Experiment
[local:midas:Stopped]/>ls "Buffer Sizes"
\end{DoxyCode}

\end{DoxyEnumerate}


\begin{DoxyItemize}
\item If the Key \char`\"{}Buffer Sizes\char`\"{} does not exist, create this key, then create a DWORD key of the buffer name to be increased, and set it to the desired value, e.g. 
\begin{DoxyCode}
[local:midas:S]/Experiment>mkdir "Buffer Sizes"
[local:midas:S]/Experiment>cd "Buffer Sizes"
[local:midas:S]/Buffer Sizes>create DWORD SYSTEM
[local:midas:S]/Buffer Sizes>set SYSTEM 0x1000000
\end{DoxyCode}

\item If the SYSTEM key exists already, just set it to the desired size.
\end{DoxyItemize}


\begin{DoxyEnumerate}
\item \hyperlink{RC_odbedit_examples_RC_odbedit_load}{Reload the ODB contents} if necessary.
\end{DoxyEnumerate}

\par


\par
 

\label{index_end}
\hypertarget{index_end}{}
 \subsubsection{Frontend Appendices}\label{FE_Appendices}
\par


 \par
 \par


\par



\begin{DoxyItemize}
\item \hyperlink{FE_Data_format}{Data formats written by the frontend}
\item \hyperlink{FE_Hardware}{Supported Hardware: MIDAS driver library}
\item \hyperlink{FE_camac_vme_function_calls}{CAMAC and VME access function calls}
\item \hyperlink{FE_utils}{Hardware Access utilities} \label{index_end}
\hypertarget{index_end}{}
 
\end{DoxyItemize}\subsubsection{Data formats written by the frontend}\label{FE_Data_format}
\par




\par
 \par
 \label{FE_Data_format_idx_format_frontend}
\hypertarget{FE_Data_format_idx_format_frontend}{}
 Only two formats are now now supported by the frontend, \hyperlink{FE_Data_format_FE_Midas_format}{MIDAS} and \hyperlink{FE_bank_construction_FE_FIXED_event_readout}{FIXED} (support for YBOS format has been discontinued (\hyperlink{NDF_ndf_sep_2010}{Sep 2010}). \hyperlink{FE_bank_construction_FE_MIDAS_event_construction}{MIDAS event construction} has been described previously. This section gives a detailed description of the MIDAS format.

Note that a frontend cannot write data directly into ROOT format. A conversion to ROOT may be done (e.g. by the data logger) from one of the supported formats (see \hyperlink{FE_table_FE_tbl_Format}{equipment list} for details).

\label{FE_Data_format_idx_format_MIDAS}
\hypertarget{FE_Data_format_idx_format_MIDAS}{}
 \label{FE_Data_format_idx_Midas_format}
\hypertarget{FE_Data_format_idx_Midas_format}{}
 \label{FE_Data_format_Midas_format}
\hypertarget{FE_Data_format_Midas_format}{}
 

 \hypertarget{FE_Data_format_FE_Midas_format}{}\paragraph{MIDAS format}\label{FE_Data_format_FE_Midas_format}
Special formats are used in MIDAS for the event header, banks and when writing to disk or tape. This section explains these formats in detail. Each event carries a 16-\/byte header. The header is generated by the front-\/end with the \hyperlink{group__bmfunctionc_gac5e3e469fb6721a502ebd80a35a328f5}{bm\_\-compose\_\-event()} routine and is used by consumers to distinguish between different events. The header is defined in the \hyperlink{structEVENT__HEADER}{EVENT\_\-HEADER} structure in \hyperlink{midas_8h}{midas.h}. It has following structure:

\begin{center} Figure 1: Event and bank headers with data block.  \end{center} 


\begin{DoxyItemize}
\item The \hyperlink{FE_table_FE_tbl_EventID}{event ID} describes the type of event. Usually 1 is used for triggered events, 2 for scaler events, 3 for HV events etc.
\item The \hyperlink{FE_table_FE_tbl_TrigMask}{trigger mask} can be used to describe the sub-\/type of an event. A trigger event can have different trigger sources like \char`\"{}physics event\char`\"{}, \char`\"{}calibration event\char`\"{}, \char`\"{}clock event\char`\"{}. These trigger sources are usually read in by the front-\/end in a pattern unit. Consumers can request events with a specific triggering mask.
\item The {\bfseries serial number} starts at 1 and is incremented by the front-\/end for each event.
\item The {\bfseries time stamp} is written by the front-\/end before an event is read out. It uses the time() function which returns the time in seconds since 1.1.1970 00:00:00 UTC.
\item The {\bfseries data size} contains the number of bytes that follows the event header.
\item The {\bfseries data area} of the event can contain information in any user format (integer, real etc.), although only certain formats are supported when events are copied to the ODB or written by the logger in ASCII format.
\end{DoxyItemize}

\label{FE_Data_format_idx_byte-ordering}
\hypertarget{FE_Data_format_idx_byte-ordering}{}
 Event headers are always kept in the {\bfseries byte ordering} of the local machine. If events are sent over the network between computers with different byte ordering, the event header is swapped automatically, but not the event contents.\hypertarget{FE_Data_format_FE_Bank_Format}{}\subparagraph{Bank Format}\label{FE_Data_format_FE_Bank_Format}
Events in MIDAS format contain \char`\"{}MIDAS banks\char`\"{}. A bank is a substructure of an event and can contain only one type of data, either a single value or an array of values. Banks have a name of exactly four characters, which are treated as a {\bfseries bank ID}. Banks in an event consist of a {\bfseries global} bank header and an {\bfseries individual} bank header for each bank.

Figure 2 shows a MIDAS event containing banks coloured to match the structure in Figure 1. This has been obtained from a MIDAS data file using the \hyperlink{RC_Monitor_RC_mdump_utility}{mdump utility}.

\par
\par
  Figure 2: Example of MIDAS banks dumped by mdump. \par
 -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ Event\# 2 -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/\par
 Evid:000d-\/ Mask:0000-\/ Serial:0-\/ Time:0x4c7a6869-\/ Dsize:48/0x30\par
 \#banks:1 -\/ Bank list:-\/SDAS-\/\par
 \par
 Bank:SDAS Length: 32(I$\ast$1)/8(I$\ast$4)/8(Type)Type:Real$\ast$4 (FMT machine dependent)\par
  1-\/$>$ 4.000e+00 1.000e+01 1.000e+00 3.400e+00 3.400e+00 3.400e+00 3.400e+00 3.400e+00\par
 \par
 -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ Event\# 3 -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/\par
 Evid:0001-\/ Mask:0000-\/ Serial:0-\/ Time:0x4c7a686b-\/ Dsize:344/0x158\par
 \#banks:2 -\/ Bank list:-\/MPETMCPP-\/\par
 \par
 Bank:MPET Length: 304(I$\ast$1)/76(I$\ast$4)/76(Type) Type:Unsigned Integer$\ast$4\par
  1-\/$>$ 0x80010000 0x00000002 0x10010000 0x00004e21 0x80020000 0x00000002 0x20020000 0x000015f4\par
 9-\/$>$ 0x20020000 0x00001660 0x20020000 0x0000185f 0x20020000 0x0000191e 0x20020000 0x000019d6\par
 17-\/$>$ 0x40020000 0x00001a37 0x20020000 0x00001a77 0x20020000 0x00001ba2 0x10020000 0x00004e22\par
 25-\/$>$ 0x80030000 0x00000002 0x20030000 0x00001637 0x20030000 0x000018d1 0x20030000 0x000019bc\par
 33-\/$>$ 0x20030000 0x00001b35 0x20030000 0x00001bb2 0x10030000 0x00004e21 0x80040000 0x00000002\par
 41-\/$>$ 0x10040000 0x00004e22 0x80050000 0x00000002 0x20050000 0x000013c5 0x20050000 0x000017f2\par
 49-\/$>$ 0x20050000 0x0000185f 0x20050000 0x00001976 0x20050000 0x00001aa8 0x10050000 0x00004e21\par
 57-\/$>$ 0x80060000 0x00000002 0x20060000 0x000015c3 0x20060000 0x000018d8 0x20060000 0x0000198d\par
 65-\/$>$ 0x20060000 0x00001ac4 0x10060000 0x00004e22 0x80070000 0x00000002 0x20070000 0x00001747\par
 73-\/$>$ 0x20070000 0x000019ae 0x10070000 0x00004e21\par
 \par
 Bank:MCPP Length: 16(I$\ast$1)/4(I$\ast$4)/4(Type) Type:Unsigned Integer$\ast$4\par
  1-\/$>$ 0x00005e4c 0x0000352d 0x00006453 0x00006d5b\par
 \par


The \char`\"{}data size total\char`\"{} is the size in bytes of all bank headers and bank data. Flags are currently not used. The bank header contains four characters as identification, a bank type that is one of the TID\_\-xxx values defined in \hyperlink{midas_8h}{midas.h}, and the data size in bytes. If the byte ordering of the contents of a complete event has to be swapped, the routine \hyperlink{group__bkfunctionc_ga44b7381af9b91fbdf2f6d59f55451ea1}{bk\_\-swap()} can be used.

\par


\par
 \label{FE_Data_format_idx_format_Midas_Tape}
\hypertarget{FE_Data_format_idx_format_Midas_Tape}{}
 \hypertarget{FE_Data_format_Tape}{}\subparagraph{Format}\label{FE_Data_format_Tape}
Events are written to disk files without any reformatting. For tapes, however, a fixed block size is used. The block size TAPE\_\-BUFFER\_\-SIZE is defined in \hyperlink{midas_8h}{midas.h} and usually 32kB. Three special events are produced by the system. A begin-\/of-\/run (BOR) and end-\/of-\/run (EOR) event is produced which contains an ASCII dump of the ODB in its data area. Their IDs is 0x8000 (BOR) and 0x8001 (EOR). A message event (ID 0x8002) is created if Log messages is enabled in the logger channel setting. The message is contained in the data area as an ASCII string. The BOR event has the number MIDAS\_\-MAGIC (0x494d or 'MI') as the trigger mask and the current run number as the serial number. A tape can therefore be identified as a MIDAS formatted tape. The routine tape\_\-copy() in the utility mtape.c is an example of how to read a tape in MIDAS format.

\label{index_end}
\hypertarget{index_end}{}


\par




\par
 \subsubsection{Supported Hardware: MIDAS driver library}\label{FE_Hardware}
\par
 

\label{FE_Hardware_idx_Hardware_driver_library}
\hypertarget{FE_Hardware_idx_Hardware_driver_library}{}


The driver library is continuously extended to suit the needs of various experiments based on the selected hardware modules. Not all commercially available modules are included as we don't have all the modules in hand. But you're more than welcome to contribute by providing your driver code if the module that you're using is not yet listed.

The {\bfseries /drivers} directory is subdivided in several directories which refers to either the type of bus ie: CAMAC, FastBus, VME, PCI, USB or type of software layer such as Class, Device, Bus.

The software layers sections are used in particular for \hyperlink{FE_Slow_Control_system}{Slow Control System}. Example are available in the distribution under {\bfseries examples/slowcont/frontend.c} including the {\bfseries hv} and {\bfseries multi} class with the {\bfseries nulldev} device and {\bfseries null} bus driver. Note: not all the device drivers implement the triple layer (Class,Device,Bus) as some include directly the hardware calls in the device layer. Please contact \href{mailto:midas@psi.ch, midas@triumf.ca?subject=VME support}{\tt midas} for specific support or for submitting new drivers.

\begin{center} Non exhaustive Drivers/ directory structure  \end{center} 


\begin{DoxyItemize}
\item \hyperlink{FE_Hardware_CAMAC_drivers}{CAMAC drivers} This section is slowly getting obsolete. But still some ISA and PCI interface are in use. Most recent development is the USB/CAMAC interface from Wiener (\href{http://www.wiener-d.com/M/17/7.html}{\tt CCUSB}). While this interface permits {\bfseries CAMAC Command Stacks} this option is not yet supported by the MIDAS API limiting the access speed of a R/W 24bit cycle to $\sim$360us!
\end{DoxyItemize}


\begin{DoxyItemize}
\item \hyperlink{FE_Hardware_VME_drivers}{VME drivers} The VME API has been revisited for a better function call set. Not all the hardware modules have been ported to this new scheme. DMA and Interrupt support have been included. The main hardware support is for the SBS PCI/VME, SIS PCI/VME, VMIC processor.
\end{DoxyItemize}


\begin{DoxyItemize}
\item \hyperlink{FE_Hardware_USB_drivers}{USB drivers} USB is getting popular in particular for the \href{http://midas.psi.ch/mscb/}{\tt MSCB} system. Following the same concept as for the CAMAC and VME, the {\bfseries musbstd.h/c} is available for USB access.
\end{DoxyItemize}


\begin{DoxyItemize}
\item \hyperlink{FE_Hardware_GPIB_drivers}{GPIB drivers}
\end{DoxyItemize}


\begin{DoxyItemize}
\item \hyperlink{FE_Hardware_Other_drivers}{Other drivers} This include the TCP/IP, Serial access layer.
\end{DoxyItemize}

\label{FE_Hardware_idx_Hardware_drivers_CAMAC}
\hypertarget{FE_Hardware_idx_Hardware_drivers_CAMAC}{}
 

 \hypertarget{FE_Hardware_CAMAC_drivers}{}\paragraph{CAMAC drivers}\label{FE_Hardware_CAMAC_drivers}
The CAMAC drivers can be used in different configuration and may have special behaviors depending on the type of hardware involved. Below are summurized some remarks about these particular hardware modules.


\begin{DoxyItemize}
\item CAMAC controllers
\begin{DoxyItemize}
\item {\bfseries }\mbox{[}hyt1331.c\mbox{]} This interface uses an ISA board to connect to the crate controller. This card implement a \char`\"{}fast\char`\"{} readout cycle by re-\/triggering the CAMAC read at the end of the previous one. This feature is unfortunately not reliable when fast processor is used. Wrong returned data can be expected when CPU clocks is above 250MHz. Attempt on \char`\"{}slowing down\char`\"{} the IO through software has not guaranteed perfect result. Contact has been taken with HYTEC in order to see if possible fix can be applied to the interface. First revision of the PC-\/card PAL has been tested but did not show improvement. CVS version of the hyt1331.c until 1.2 contains \char`\"{}fast readout
  cycle\char`\"{} and should not be trusted. CVS 1.3 driver revision contains a patch to this problem. In the mean time you can apply your own patch (see \hyperlink{FAQ}{SECTION 12: Frequently Asked Questions}) and also \href{http://www.hytec-electronics.co.uk/index.html}{\tt Hytec })
\item {\bfseries  \mbox{[}hyt1331.c Version $>$= 1.8.3\mbox{]}} This version has been modified for 5331 PCI card support running under the \hyperlink{FE_utils_FE_dio_utility}{dio -\/ direct I/O driver}.
\item {\bfseries \mbox{[}khyt1331.c Version $>$= 1.8.3\mbox{]}} A full Linux driver is available for the 5331 PCI card interfacing to the hyt1331. The kernel driver has been written for the Linux kernel 2.4.2, which comes with RedHat 7.1. It could be ported back to the 2.2.x kernel because no special feature of 2.4.x are used, although many data structures and function \hyperlink{structparameters}{parameters} have changed between 2.2 and 2.4, which makes the porting a bit painful. The driver supports only one 5331 card with up to four CAMAC crates.
\item {\bfseries \mbox{[}kcs292x.c\mbox{]}} The 2926 is an 8 bit ISA board, while the 2927 is a 16bit ISA board. An equivalent PCI interface (2915) exists but is not yet supported by MIDAS (See \href{http://www.kscorp.com/www/camac/1000/2915.html}{\tt KCS}). No support for Windowx yet. \par
\par
 Both cards can be used also through a proper Linux driver {\itshape camaclx.c\/}. This requires to first load a module {\itshape camac-\/kcs292x.o\/}. This software is available but not part of the MIDAS distribution yet. Please contact \href{mailto:midas@triumf.ca?subject=KCS driver}{\tt midas} for further information. \par
\par

\item {\bfseries \mbox{[}wecc32.c\mbox{]}} The CAMAC crate controller CC32 interface to a PCI card... you will need the proper Linux module... Currently under test. WindowsNT and W95 drivers available but not implemented under MIDAS. (see \href{http://www.wiener-d.com/cc32.htm}{\tt CC32})
\item {\bfseries \mbox{[}dsp004.c\mbox{]}} The dsp004 is an 8 bit ISA board PC interface which connect to the PC6002 CAMAC crate controller. This module is not being manufactured anymore, but somehow several labs still have that controller in use.
\item {\bfseries \mbox{[}ces8210.c\mbox{]}} The CAMAC crate controller CBD8210 interface is a VME module to give access up to 7 CAMAC crate. In conjunction with the \hyperlink{mvmestd_8h}{mvmestd.h} and \hyperlink{mcstd_8h}{mcstd.h}, this driver can be used on any MIDAS/VME interface.
\item {\bfseries \mbox{[}jorway73a.c\mbox{]}} The CAMAC crate controller Jorway73a is accessed through SCSI commands. This driver implement the \hyperlink{mcstd_8h}{mcstd.h} calls.
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyItemize}
\item CAMAC drivers
\begin{DoxyItemize}
\item {\bfseries }\mbox{[}camacnul.c\mbox{]} Handy fake CAMAC driver for code development.
\item {\bfseries }\mbox{[}camacrpc.c\mbox{]} Remote Procedure Call CAMAC driver used for accessing the CAMAC server part of the standard MIDAS frontend code. This driver is used for example in the \hyperlink{FE_utils_FE_mcnaf_utility}{mcnaf} and \hyperlink{RC_mhttpd_utility}{mhttpd} utilities.
\end{DoxyItemize}
\end{DoxyItemize}

\label{FE_Hardware_idx_Hardware_drivers_VME}
\hypertarget{FE_Hardware_idx_Hardware_drivers_VME}{}
 

 \hypertarget{FE_Hardware_VME_drivers}{}\paragraph{VME drivers}\label{FE_Hardware_VME_drivers}
The VME modules drivers can be interfaced to any type of PCI/VME controller. This is done by dedicated MIDAS VME Standard calls from the \hyperlink{mvmestd_8h}{mvmestd.h} files.


\begin{DoxyItemize}
\item PCI/VME interface
\begin{DoxyItemize}
\item {\bfseries }\mbox{[}sis1100.c\mbox{]} PCI/VME with optical fiber link. Driver is under development (March 2002). (see \href{http://www.sruck.de/vme.htm}{\tt SIS}).
\item {\bfseries }\mbox{[}bt617.c\mbox{]} Routines for accessing VME over SBS Bit3 Model 617 interface under Windows NT using the NT device driver Model 983 and under Linux using the vmehb device driver. The VME calls are implemented for the \char`\"{}mvmestd\char`\"{} MIDAS VME Standard. (see \href{http://www.sbs.com/computer/products/cp_adapters.shtml}{\tt Bit3}).
\item {\bfseries }\mbox{[}wevmemm.c\mbox{]} PCI/VME Wiener board supported. (see \href{http://www.wiener-d.com/vmepci.htm}{\tt Wiener PCI}).
\item \mbox{[}vxVME.c\mbox{]} mvmestd implementation for VxWorks Operating System. Does require cross compiler for the VxWorks target hardware processor and proper WindRiver license.
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyItemize}
\item VME modules
\begin{DoxyItemize}
\item {\bfseries }\mbox{[}\hyperlink{lrs1190_8c}{lrs1190.c}\mbox{]} LeCroy Dual-\/port memory ECL 32bits.
\item {\bfseries }\mbox{[}\hyperlink{lrs1151_8c}{lrs1151.c}\mbox{]} LeCroy 16 ECL 32bits scalers.
\item {\bfseries }\mbox{[}lrs2365.c\mbox{]} LeCroy Logic matrix.
\item {\bfseries }\mbox{[}lrs2373.c\mbox{]} LeCroy Memory Lookup unit.
\item {\bfseries }\mbox{[}sis3700.c\mbox{]} SIS FERA Fifo 32 bits.
\item {\bfseries }\mbox{[}\hyperlink{sis3801_8c}{sis3801.c}\mbox{]} SIS MultiChannel Scalers 32 channels.
\item {\bfseries }\mbox{[}\hyperlink{sis3803_8c}{sis3803.c}\mbox{]} SIS Standard 32 Scalers 32 bits.
\item {\bfseries }\mbox{[}ps7106.c\mbox{]} Phillips Scientific Discriminator.
\item {\bfseries }\mbox{[}ces8210.c\mbox{]} CES CAMAC crate controller.
\item {\bfseries }\mbox{[}\hyperlink{vmeio_8c}{vmeio.c}\mbox{]} Triumf VMEIO General purpose I/O 24bits.
\end{DoxyItemize}
\end{DoxyItemize}

\label{FE_Hardware_idx_Hardware_drivers_USB}
\hypertarget{FE_Hardware_idx_Hardware_drivers_USB}{}
 

 \hypertarget{FE_Hardware_USB_drivers}{}\paragraph{USB drivers}\label{FE_Hardware_USB_drivers}
This section is under development for the Wiener USB/CAMAC CCUSB controller. Support for Linux and XP is undergo. Please contact \href{mailto:midas@psi.ch, midas@triumf.ca?subject=USB driver}{\tt midas} for further information.

\label{FE_Hardware_idx_Hardware_drivers_GPIB}
\hypertarget{FE_Hardware_idx_Hardware_drivers_GPIB}{}
 

 \hypertarget{FE_Hardware_GPIB_drivers}{}\paragraph{GPIB drivers}\label{FE_Hardware_GPIB_drivers}
There is no specific GPIB driver part of the MIDAS package. But GPIB is used at Triumf under WindowsNT for several Slow Control frontends. The basic GPIB DLL library is provided by \href{http://www.ni.com/default.htm}{\tt National Instrument}. Please contact \href{mailto:midas@triumf.ca?subject=GPIB driver}{\tt midas} for further information.

For GPIB Linux support please refer to \href{http://www.llp.fu-berlin.de/pool/software/busses/}{\tt The Linux Lab Project}

\label{FE_Hardware_idx_Hardware_drivers_other}
\hypertarget{FE_Hardware_idx_Hardware_drivers_other}{}
 

 \hypertarget{FE_Hardware_Other_drivers}{}\paragraph{Other drivers}\label{FE_Hardware_Other_drivers}

\begin{DoxyItemize}
\item {\bfseries \mbox{[}Serial driver\mbox{]}} rs232.c communication routines.
\item {\bfseries \mbox{[}Network driver\mbox{]}} {\bfseries tcpip.c/h} TCP/IP socket communication routines.
\item {\bfseries \mbox{[}SCSI driver\mbox{]}} Support for the jorway73a SCSI/CAMAC controller under Linux has been done by Greg Hackman (see \hyperlink{FE_Hardware_CAMAC_drivers}{CAMAC drivers}).
\end{DoxyItemize}

\par
 \par


 \par
 \label{index_end}
\hypertarget{index_end}{}
 \subsubsection{CAMAC and VME access function calls}\label{FE_camac_vme_function_calls}
\par
 

\par
 \label{FE_camac_vme_function_calls_idx_hardware_standard_interface}
\hypertarget{FE_camac_vme_function_calls_idx_hardware_standard_interface}{}
 MIDAS defines its own set of CAMAC and VME calls in order to unify the different hardware modules that it supports. This interface method permits code to be totally {\itshape  hardware as well as OS independent \/}. For example, the same user code developed on a system can be used as a template for another application on a different operating system.

MIDAS provides {\bfseries Standard} {\bfseries Interfaces} for VME and CAMAC
\begin{DoxyItemize}
\item {\bfseries \hyperlink{mcstd_8h}{mcstd.h}} for {\bfseries CAMAC} access
\item {\bfseries \hyperlink{mvmestd_8h}{mvmestd.h}} for {\bfseries VME} access
\end{DoxyItemize}

An extra CAMAC interface built on top of {\bfseries mcstd} provides the ESONE standard CAMAC calls (\hyperlink{esone_8c}{esone.c}).

Refer to the corresponding directories under \$(\hyperlink{BuildingOptions_BO_MIDASSYS}{MIDASSYS}){\itshape /drivers\/} to find out what module of each family is already supported by the current MIDAS distribution. The directory \$(\hyperlink{BuildingOptions_BO_MIDASSYS}{MIDASSYS}){\itshape /drivers/divers\/} contains older drivers which have not yet been converted to the latest API.

\label{FE_camac_vme_function_calls_idx_hardware_standard_interface_CAMAC}
\hypertarget{FE_camac_vme_function_calls_idx_hardware_standard_interface_CAMAC}{}
 

 \hypertarget{FE_camac_vme_function_calls_FE_Midas_CAMAC_standard_functions}{}\paragraph{MIDAS CAMAC standard functions}\label{FE_camac_vme_function_calls_FE_Midas_CAMAC_standard_functions}
Please refer to \hyperlink{group__mcstdfunctionh}{Camac Functions (camxxx)} for function description.

\label{FE_camac_vme_function_calls_idx_hardware_CAMAC_functions_ESONE}
\hypertarget{FE_camac_vme_function_calls_idx_hardware_CAMAC_functions_ESONE}{}
 

 \hypertarget{FE_camac_vme_function_calls_FE_ESONE_CAMAC_standard_functions}{}\paragraph{ESONE CAMAC standard functions}\label{FE_camac_vme_function_calls_FE_ESONE_CAMAC_standard_functions}
{\bfseries Not all the functionality of ESONE standard has been fully tested}

Please refer to \hyperlink{group__mesonefunctionc}{Camac Functions (Esone)} for function description.

\label{FE_camac_vme_function_calls_idx_hardware_standard_interface_VME}
\hypertarget{FE_camac_vme_function_calls_idx_hardware_standard_interface_VME}{}
 

 \hypertarget{FE_camac_vme_function_calls_FE_Midas_VME_standard_functions}{}\paragraph{MIDAS VME standard functions}\label{FE_camac_vme_function_calls_FE_Midas_VME_standard_functions}
This API provides basic VME access through a {\bfseries simple} set of functions. Refer to \hyperlink{group__mvmestdfunctionh}{VME Functions (mvme\_\-xxx)} for more specific information. \hyperlink{group__mvmestdfunctionh_ga13db7fc7c7c022e46fadd8fc4dc40047}{mvme\_\-open()} contains a general access code sample summarizing most of the mvme commands.

\label{FE_camac_vme_function_calls_idx_hardware_computer-busy}
\hypertarget{FE_camac_vme_function_calls_idx_hardware_computer-busy}{}
 

 \hypertarget{FE_camac_vme_function_calls_FE_Compute_Busy_Logic}{}\paragraph{Computer Busy Logic}\label{FE_camac_vme_function_calls_FE_Compute_Busy_Logic}
A \char`\"{}computer busy logic\char`\"{} has to be implemented for a front-\/end to work properly. The reason for this is that some ADC modules can be re-\/triggered. If they receive more than one gate pulse before being read out, they accumulate the input charge that leads to incorrect results. Therefore only one gate pulse should be sent to the ADCs, and additional pulses must be blocked before the event is read out by the front-\/end. This operation is usually performed by a latch module, which is set by the trigger signal and reset by the computer after it has read out the event.

The output of this latch is shaped (limited in its pulse width to match the ADC gate width) and distributed to the ADCs. This scheme has two problems. The computer generates the reset signal, usually by two CAMAC output functions to a CAMAC IO unit. Therefore the duration of the pulse is a couple of ms. There is a non-\/negligible probability that during the reset pulse there is another hardware trigger. If this happens and both inputs of the latch are active, its function is undefined. Usually it generates several output pulses that lead to erroneous ADC values. The second problem lies in the fact that the latch can be just reset when a trigger input is active. This can happen since trigger signals usually have a width of a few tens of nanoseconds. In this case the latch output signal does not carry the timing of the trigger signal, but the timing of the reset signal. The incorrect timing of the output can lead to false ADC and TDC signals. To overcome this problem, a more elaborate scheme is necessary. One possible solution is the use of a latch module with edge-\/sensitive input and veto input. At PSI, the module \char`\"{}D. TRIGGER / DT102\char`\"{} can be used. The veto input is also connected to the computer:

\begin{center} Latched trigger layout.  \end{center} 

To reset this latch, the following bit sequence is applied to the computer output (signals are displayed active low):

\begin{center} Improved Latched trigger layout.  \end{center} 

The active veto signal during the reset pulse avoids the case where the latch can receive a \char`\"{}set\char`\"{} and a \char`\"{}reset\char`\"{} simultaneously. The edge-\/sensitive input ensures that the latch can only trigger on a leading edge of a trigger signal, and not when the veto signal is removed. This ensures that the timing of the trigger is always carried at the ADC/TDC gate signal.

\begin{center} Veto Timing.  \end{center} 

\par
 

\par
 \label{index_end}
\hypertarget{index_end}{}
 \subsubsection{Hardware Access utilities}\label{FE_utils}
\par
 

\par



\begin{DoxyItemize}
\item \hyperlink{FE_utils_FE_mcnaf_utility}{mcnaf -\/ CAMAC hardware access}
\item \hyperlink{FE_utils_FE_dio_utility}{dio -\/ direct I/O driver}
\end{DoxyItemize}\hypertarget{FE_utils_FE_mcnaf_utility}{}\paragraph{mcnaf        -\/ CAMAC hardware access}\label{FE_utils_FE_mcnaf_utility}
{\bfseries mcnaf} is an interactive CAMAC tool which allows \char`\"{}direct\char`\"{} access to the CAMAC hardware. This application is operational under either of the two following conditions:
\begin{DoxyEnumerate}
\item {\bfseries mcnaf} has been built against a particular CAMAC driver (see \hyperlink{FE_Hardware_CAMAC_drivers}{CAMAC drivers}).
\item A user frontend code using a valid CAMAC driver is currently active. In this case the frontend acts as a RPC CAMAC server and will handle the CAMAC request. This last option is only available if the frontend code (\hyperlink{mfe_8c}{mfe.c}) from the \hyperlink{BuildingOptions_BO_building_option}{Building Options} has included the \hyperlink{BuildingOptions_BO_HAVE_CAMAC}{HAVE\_\-CAMAC} pre-\/compiler flag.
\end{DoxyEnumerate}


\begin{DoxyItemize}
\item {\bfseries  Arguments }
\begin{DoxyItemize}
\item \mbox{[}-\/h \mbox{]} : help
\item \mbox{[}-\/h hostname \mbox{]} : host name
\item \mbox{[}-\/e exptname \mbox{]} : experiment name
\item \mbox{[}-\/f frontend name\mbox{]} : Frontend name to connect to.
\item \mbox{[}-\/s RPC server name\mbox{]} : CAMAC RPC server name for remote connection.
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyItemize}
\item {\bfseries  Building application } The {\bfseries midas/utils/makefile.mcnaf} will build a collection of {\bfseries mcnaf} applications which are hardware dependent, see {\bfseries  Example } below:
\begin{DoxyItemize}
\item {\bfseries \mbox{[}miocnaf\mbox{]}} cnaf application using the declared CAMAC hardware DRIVER (kcs2927 in this case). To be used with {\bfseries dio} CAMAC application starter (see \hyperlink{FE_utils_FE_dio_utility}{dio -\/ direct I/O driver}).
\item {\bfseries \mbox{[}mwecnaf\mbox{]}} cnaf application using the WI-\/E-\/N-\/ER PCI/CAMAC interface (see \hyperlink{FE_Hardware_CAMAC_drivers}{CAMAC drivers}). Please contact: \href{mailto:midas@triumf.ca}{\tt midas@triumf.ca} for further information.
\item {\bfseries \mbox{[}mcnaf\mbox{]}} cnaf application using the CAMAC RPC capability of any MIDAS frontend program having CAMAC access.
\item {\bfseries \mbox{[}mdrvcnaf\mbox{]}} cnaf application using the Linux CAMAC driver for either kcs2927, kcs2926, dsp004. This application would require to have the proper Linux module loaded in the system first. Please contact mailto:\href{mailto:midas@triumf.ca}{\tt midas@triumf.ca} for further information.
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyCode}
Thu> cd /midas/utils
Thu> make -f makefile.mcnaf DRIVER=kcs2927
gcc -O3 -I../include -DOS_LINUX -c -o mcnaf.o mcnaf.c
gcc -O3 -I../include -DOS_LINUX -c -o kcs2927.o ../drivers/bus/kcs2927.c
gcc -O3 -I../include -DOS_LINUX -o miocnaf mcnaf.o kcs2927.o  ../linux/lib/libmid
      as.a -lutil
gcc -O3 -I../include -DOS_LINUX -c -o wecc32.o ../drivers/bus/wecc32.c
gcc -O3 -I../include -DOS_LINUX -o mwecnaf mcnaf.o wecc32.o  ../linux/lib/libmida
      s.a -lutil 
gcc -O3 -I../include -DOS_LINUX -c -o camacrpc.o ../drivers/bus/camacrpc.c
gcc -O3 -I../include -DOS_LINUX -o mcnaf mcnaf.o camacrpc.o  ../linux/lib/libmida
      s.a -lutil 
gcc -O3 -I../include -DOS_LINUX -c -o camaclx.o ../drivers/bus/camaclx.c
gcc -O3 -I../include -DOS_LINUX -o mdrvcnaf mcnaf.o camaclx.o  ../linux/lib/libmi
      das.a -lutil 
rm *.o
\end{DoxyCode}



\begin{DoxyItemize}
\item {\bfseries  Running application }
\begin{DoxyItemize}
\item Direct CAMAC access: This requires the computer to have the proper CAMAC interface installed and the {\bfseries BASE} ADDRESS matching the value defined in the corresponding CAMAC driver. For kcs2926.c, kcs2927.c, dsp004.c, hyt1331.c, the base address (CAMAC\_\-BASE) is set to 0x280. 
\begin{DoxyCode}
   >dio miocnaf
\end{DoxyCode}

\item RPC CAMAC through frontend: This requires to have a frontend running which will be able to serve the CAMAC RPC request. Any MIDAS frontend has that capability built-\/in but it has to have the proper CAMAC driver included in it. 
\begin{DoxyCode}
     >mcnaf -e <expt> -h <host> -f <fe_name>
\end{DoxyCode}

\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyItemize}
\item {\bfseries  Usage } 
\begin{DoxyCode}
  ........
\end{DoxyCode}

\end{DoxyItemize}



 \hypertarget{FE_utils_FE_dio_utility}{}\paragraph{dio          -\/ direct I/O driver}\label{FE_utils_FE_dio_utility}
Direct I/O task provider (LINUX).

If no particular Linux driver is installed for the CAMAC access, the {\bfseries dio-\/} program will allow you to access the I/O ports to which the CAMAC interface card is connected to.


\begin{DoxyItemize}
\item {\bfseries  Arguments }
\begin{DoxyItemize}
\item \mbox{[}application name \mbox{]} : Program name requiring I/O permission.
\end{DoxyItemize}
\item {\bfseries  Usage } 
\begin{DoxyCode}
 >dio miocnaf
 >dio frontend 
\end{DoxyCode}

\item {\bfseries  Remark }
\item This \char`\"{}hacking\char`\"{} utility restricts the access to a range of I/O ports from 0x200 to 0x3FF.
\end{DoxyItemize}


\begin{DoxyItemize}
\item As this mode if I/O access by-\/passes the driver (if any), concurrent access to the same I/O port may produce unexpected result and in the worst case it will freeze the computer. It is therefore important to ensure to run one and only one dio application to a given port in order to prevent potential hangup problem.
\end{DoxyItemize}


\begin{DoxyItemize}
\item Interrupt handling, DMA capabilities of the interface will not be accessible under this mode of operation.
\end{DoxyItemize}

\label{index_end}
\hypertarget{index_end}{}
 \par


 \par
 